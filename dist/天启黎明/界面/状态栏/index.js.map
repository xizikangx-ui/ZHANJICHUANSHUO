{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/node_modules/.pnpm/vue-loader@17.4.2_vue@3.5.29_typescript@6.0.0-dev.20250807__webpack@5.105.2/node_modules/vue-loader/dist/exportHelper.js","src://tavern_helper_template/webpack/bootstrap","src://tavern_helper_template/webpack/runtime/compat get default export","src://tavern_helper_template/webpack/runtime/define property getters","src://tavern_helper_template/webpack/runtime/hasOwnProperty shorthand","src://tavern_helper_template/external var \"Vue\"","src://tavern_helper_template/external var \"_\"","src://tavern_helper_template/node_modules/.pnpm/@vueuse+shared@13.9.0_vue@3.5.29_typescript@6.0.0-dev.20250807_/node_modules/@vueuse/shared/index.mjs","src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src//schema.ts","src://tavern_helper_template/src////store.ts","src://tavern_helper_template/util/mvu.ts","src://tavern_helper_template/node_modules/.pnpm/@vueuse+core@13.9.0_vue@3.5.29_typescript@6.0.0-dev.20250807_/node_modules/@vueuse/core/index.mjs","webpack://tavern_helper_template/./src////App.vue?0b11","webpack://tavern_helper_template/src////App.vue?bc2f","src://tavern_helper_template/src////index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = Vue;","const __WEBPACK_NAMESPACE_OBJECT__ = _;","import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, shallowReadonly, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn, options = {}) {\n  let v = void 0;\n  let track;\n  let trigger;\n  let dirty = true;\n  const update = () => {\n    dirty = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\", ...options });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty) {\n          v = get(v);\n          dirty = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const clear = () => {\n    fns.clear();\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger,\n    clear\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = /* @__NO_SIDE_EFFECTS__ */ (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null && !hasInjectionContext())\n    throw new Error(\"injectLocal must be called in setup\");\n  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction provideLocal(key, value) {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  return provide(key, value);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createRef(value, deep) {\n  if (deep === true) {\n    return ref(value);\n  } else {\n    return shallowRef(value);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue$1;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue$1(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue$1(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue$1(defaultValue);\n      trigger();\n    }, toValue$1(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  let lastInvoker;\n  const filter = (invoke) => {\n    const duration = toValue$1(ms);\n    const maxDuration = toValue$1(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = void 0;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      lastInvoker = invoke;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = void 0;\n          resolve(lastInvoker());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = void 0;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue$1(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter, options = {}) {\n  const {\n    initialState = \"active\"\n  } = options;\n  const isActive = toRef(initialState === \"active\");\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction pxValue(px) {\n  return px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(toValue$1(value));\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return shallowReadonly(debounced);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(toValue$1(value));\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    const [target, key, value] = args;\n    target[key] = value;\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    initialState = \"active\",\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  const targetsArray = toArray(targets);\n  return watch(\n    source,\n    (newValue) => targetsArray.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue$1(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nconst toValue = toValue$1;\nconst resolveUnref = toValue$1;\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue$1(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue$1(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue$1(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayDifference(...args) {\n  var _a, _b;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  const {\n    symmetric = false\n  } = (_b = args[3]) != null ? _b : {};\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  const diff1 = computed(() => toValue$1(list).filter((x) => toValue$1(values).findIndex((y) => compareFn(x, y)) === -1));\n  if (symmetric) {\n    const diff2 = computed(() => toValue$1(values).filter((x) => toValue$1(list).findIndex((y) => compareFn(x, y)) === -1));\n    return computed(() => symmetric ? [...toValue$1(diff1), ...toValue$1(diff2)] : toValue$1(diff1));\n  } else {\n    return diff1;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue$1(list).every((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).filter(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue$1(\n    toValue$1(list).find((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue$1(list).findIndex((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue$1(\n    !Array.prototype.findLast ? findLast(toValue$1(list), (element, index, array) => fn(toValue$1(element), index, array)) : toValue$1(list).findLast((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue$1(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue$1(value2);\n  return computed(() => toValue$1(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue$1(element),\n    toValue$1(value),\n    index,\n    toValue$1(array)\n  )));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).join(toValue$1(separator)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).map(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue$1(sum), toValue$1(value), index);\n  return computed(() => {\n    const resolved = toValue$1(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue$1(args[0]()) : toValue$1(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArraySome(list, fn) {\n  return computed(() => toValue$1(list).some((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue$1(list).map((element) => toValue$1(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = shallowRef(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count: shallowReadonly(count), inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|z{1,4}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const stripTimeZone = (dateString) => {\n    var _a2;\n    return (_a2 = dateString.split(\" \")[1]) != null ? _a2 : \"\";\n  };\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true),\n    z: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"longOffset\" }))\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue$1(date)), toValue$1(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = shallowRef(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue$1(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive: shallowReadonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = shallowRef(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter: shallowReadonly(counter),\n      reset,\n      ...controls\n    };\n  } else {\n    return shallowReadonly(counter);\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = shallowRef((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return shallowReadonly(ms);\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  const isPending = shallowRef(false);\n  let timer;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    if (immediateCallback)\n      cb();\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = void 0;\n      cb(...args);\n    }, toValue$1(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: shallowReadonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue$1(value);\n    if (typeof method === \"function\")\n      resolved = method(resolved);\n    else if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToString(value) {\n  return computed(() => `${toValue$1(value)}`);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = shallowRef(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue$1(truthyValue);\n      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...typeof source === \"function\" ? source() : Array.isArray(source) ? source : toValue$1(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = shallowRef(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue$1(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    let ignore = false;\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore = true;\n      updater();\n      ignore = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    let ignoreCounter = 0;\n    let syncCounter = 0;\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter = syncCounter;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter;\n      updater();\n      ignoreCounter += syncCounter - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter > 0 && ignoreCounter === syncCounter;\n          ignoreCounter = 0;\n          syncCounter = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      once: true\n    }\n  );\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue$1(item));\n  return toValue$1(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createRef, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","const __WEBPACK_NAMESPACE_OBJECT__ = z;","export const Schema = z\n    .object({\n    : z\n        .object({\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n            : z.enum(['', '', '']).prefault(''),\n            : z\n                .enum(['', '', '', '', '', ''])\n                .prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 12, 80)).prefault(21),\n            : z.enum(['', '']).prefault(''),\n            : z.boolean().prefault(false),\n            : z.boolean().prefault(false),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.coerce.number().prefault(0),\n        })\n            .prefault({}),\n        : z\n            .array(z\n            .object({\n            : z.string().prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, -200, 1000)).prefault(0),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.record(z.string().describe(''), z.coerce.number().prefault(0)).prefault({}),\n            : z.coerce.number().prefault(0),\n        })\n            .prefault({}))\n            .prefault([]),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            NPC: z.boolean().prefault(false),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n            : z.coerce.number().prefault(0),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n            : z.coerce.number().prefault(0),\n        })\n            .prefault({}),\n    })\n        .prefault({}),\n    : z\n        .object({\n        : z.string().prefault('177828 08:00'),\n        : z.string().prefault(' '),\n        : z.string().prefault(''),\n        : z.enum(['', '', '', '']).prefault(''),\n        : z.record(z.string().describe(''), z.string().describe('')).prefault({}),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.enum(['', '']).prefault(''),\n            : z.enum(['', '', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 4)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 7)).prefault(0),\n            : z.boolean().prefault(false),\n            : z.boolean().prefault(false),\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n        })\n            .prefault({}),\n        NPC: z.record(z.string().describe('NPC'), z.object({\n            : z.string().prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, -200, 1000)).prefault(0),\n            : z.string().prefault(''),\n            : z.enum(['', '', '', '', '', '', '', '']).prefault(''),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.record(z.string().describe(''), z.coerce.number().prefault(0)).prefault({}),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 99999)).prefault(0),\n            : z.enum(['', '']).prefault(''),\n            : z.array(z.string()).prefault([]),\n            : z.coerce.number().prefault(0),\n            : z.coerce.number().prefault(0),\n        }).prefault({})).prefault({}),\n        NPC: z.record(z.string().describe('NPC'), z.object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(0),\n            : z.coerce.number().prefault(0),\n            : z.boolean().prefault(false),\n        }).prefault({})).prefault({}),\n    })\n        .prefault({}),\n    : z\n        .object({\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 5)).prefault(1),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(20),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(18),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(18),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(18),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(20),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(12),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 1, 20)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 20)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(10),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(0),\n            : z.boolean().prefault(false),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.boolean().prefault(false),\n            : z.enum(['', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(8),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(0),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(100),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 9999)).prefault(100),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(100),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 9999)).prefault(100),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 100)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 9)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(10),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 99)).prefault(10),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.array(z.string()).prefault([]),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(4),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.record(z.string().describe('ID'), z.boolean()).prefault({}),\n            : z.string().prefault(''),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.enum(['', '', '', '', '', '', '', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 99999)).prefault(0),\n            : z.string().prefault(''),\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.enum(['', '', '']).prefault(''),\n            : z.boolean().prefault(false),\n            : z.enum(['', '', '', '']).prefault(''),\n            : z.enum(['', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 999)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.string().prefault(''),\n            : z.record(z.string().describe(''), z.array(z.string()).prefault([])).prefault({}),\n            : z\n                .object({\n                : z.boolean().prefault(false),\n                : z\n                    .enum(['', '', '', '', '', '', ''])\n                    .prefault(''),\n                : z.enum(['', '', '', '', '']).prefault(''),\n                : z.coerce.number().transform(v => _.clamp(v, 1, 100)).prefault(11),\n                : z.coerce.number().transform(v => _.clamp(v, -50, 50)).prefault(5),\n                : z.coerce.number().transform(v => _.clamp(v, -100, 100)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 0.1, 3)).prefault(1),\n                : z.enum(['', '', '', '', '', '']).prefault(''),\n                : z.coerce.number().transform(v => _.clamp(v, 100, 2000)).prefault(500),\n                : z\n                    .object({\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                })\n                    .prefault({}),\n                : z\n                    .object({\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(0),\n                })\n                    .prefault({}),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, -1, 1)).prefault(0),\n                : z.string().prefault(''),\n                : z.boolean().prefault(false),\n                : z.string().prefault(''),\n                : z.array(z.string()).prefault([]),\n                : z.array(z.string()).prefault([]),\n                : z.enum(['', '', '', '']).prefault(''),\n                : z.enum(['', '', '', '', '']).prefault(''),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(3),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(3),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n                : z.string().prefault(''),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 99999)).prefault(100),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 99999)).prefault(100),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 9999)).prefault(0),\n                : z.string().prefault(''),\n            })\n                .prefault({}),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.record(z.string().describe(''), z\n                .object({\n                : z.coerce.number().transform(v => _.clamp(v, 0, 8)).prefault(1),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 8)).prefault(2),\n                : z.string().prefault(''),\n            })\n                .prefault({})).prefault({}),\n            : z.record(z.string().describe(''), z.string()).prefault({}),\n            : z.record(z.string().describe(''), z.string().describe('')).prefault({}),\n        })\n            .prefault({}),\n        : z.record(z.string().describe(''), z\n            .object({\n            : z.enum(['', '', '']).prefault(''),\n            : z.string().prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 99)).prefault(1),\n        })\n            .prefault({})).prefault({}),\n        : z\n            .object({\n            : z.string().prefault(''),\n            : z.enum(['', '', '', '', '', '', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 10)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.string().prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.enum(['', '', '', '']).prefault(''),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.coerce.number().prefault(0),\n        })\n            .prefault({}),\n    })\n        .prefault({}),\n    : z\n        .object({\n        : z.boolean().prefault(false),\n        : z.record(z.string().describe(''), z\n            .object({\n            : z.enum(['', '']).prefault(''),\n            : z.boolean().prefault(false),\n        })\n            .prefault({})).prefault({}),\n        : z.record(z.string().describe(''), z\n            .object({\n            : z.enum(['', '', '', '', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 999)).prefault(1),\n            : z.coerce.number().transform(v => _.clamp(v, 1, 999999999)).prefault(1),\n        })\n            .prefault({})).prefault({}),\n        : z\n            .object({\n            : z.boolean().prefault(false),\n            : z.string().prefault(''),\n            : z\n                .enum(['', '', '', ''])\n                .prefault(''),\n            : z.enum(['', '', '']).prefault(''),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999)).prefault(0),\n            : z.string().prefault(''),\n            : z.string().prefault(''),\n            : z\n                .array(z\n                .object({\n                : z.coerce.number().transform(v => _.clamp(v, 1, 999)).prefault(1),\n                : z.string().prefault(''),\n                : z.enum(['', '', '', '']).prefault(''),\n                : z\n                    .object({\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 9)).prefault(0),\n                    : z.coerce.number().transform(v => _.clamp(v, 0, 9)).prefault(0),\n                    : z.boolean().prefault(false),\n                    : z.boolean().prefault(false),\n                })\n                    .prefault({}),\n            })\n                .prefault({}))\n                .prefault([]),\n        })\n            .prefault({}),\n        : z\n            .object({\n            : z.coerce.number().transform(v => _.clamp(v, 0, 99999999)).prefault(0),\n            : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(0),\n            : z.record(z.string().describe(''), z\n                .object({\n                : z.enum(['', '', '', '', '', '']).prefault(''),\n                : z.coerce.number().transform(v => _.clamp(v, 0, 999999)).prefault(0),\n                : z.coerce.number().transform(v => _.clamp(v, 1, 999999999)).prefault(1),\n                : z.string().prefault(''),\n                : z.string().prefault(''),\n                : z.array(z.string()).prefault([]),\n                : z.boolean().prefault(true),\n            })\n                .prefault({})).prefault({}),\n            : z.array(z.string()).prefault([]),\n        })\n            .prefault({}),\n    })\n        .prefault({}),\n    : z.record(z.string().describe(''), z.string().describe('')).prefault({}),\n})\n    .prefault({});\n","import { defineMvuDataStore } from '@util/mvu';\nimport { Schema } from '../../schema';\n\nexport const useDataStore = defineMvuDataStore(Schema, { type: 'message', message_id: getCurrentMessageId() });\n","export function defineMvuDataStore(schema, variable_option, additional_setup) {\n    if (variable_option.type === 'message' &&\n        (variable_option.message_id === undefined || variable_option.message_id === 'latest')) {\n        variable_option.message_id = -1;\n    }\n    return defineStore(`mvu_data.${_(variable_option)\n        .entries()\n        .sortBy(entry => entry[0])\n        .map(entry => entry[1])\n        .join('.')}`, errorCatched(() => {\n        const data = ref(schema.parse(_.get(getVariables(variable_option), 'stat_data', {}), { reportInput: true }));\n        if (additional_setup) {\n            additional_setup(data);\n        }\n        useIntervalFn(() => {\n            const stat_data = _.get(getVariables(variable_option), 'stat_data', {});\n            const result = schema.safeParse(stat_data);\n            if (result.error) {\n                return;\n            }\n            if (!_.isEqual(data.value, result.data)) {\n                ignoreUpdates(() => {\n                    data.value = result.data;\n                });\n                if (!_.isEqual(stat_data, result.data)) {\n                    updateVariablesWith(variables => _.set(variables, 'stat_data', result.data), variable_option);\n                }\n            }\n        }, 2000);\n        const { ignoreUpdates } = watchIgnorable(data, new_data => {\n            const result = schema.safeParse(new_data);\n            if (result.error) {\n                return;\n            }\n            if (!_.isEqual(new_data, result.data)) {\n                ignoreUpdates(() => {\n                    data.value = result.data;\n                });\n            }\n            updateVariablesWith(variables => _.set(variables, 'stat_data', result.data), variable_option);\n        }, { deep: true });\n        return { data };\n    }));\n}\n","import { noop, makeDestructurable, camelize, isClient, toArray, watchImmediate, isObject, tryOnScopeDispose, isIOS, notNullish, tryOnMounted, objectOmit, promiseTimeout, until, injectLocal, provideLocal, pxValue, increaseWithUnit, objectEntries, createRef, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, useIntervalFn, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, bypassFilter, createFilterWrapper, toRefs, watchOnce, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, identity, isDef, whenever, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, shallowRef, ref, watchEffect, computed, inject, defineComponent, h, TransitionGroup, Fragment, shallowReactive, toValue, unref, getCurrentInstance, onMounted, watch, customRef, onUpdated, readonly, reactive, hasInjectionContext, toRaw, shallowReadonly, nextTick, markRaw, getCurrentScope, isReadonly, onBeforeUpdate } from 'vue';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  var _a;\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    flush = \"pre\",\n    evaluating = void 0,\n    shallow = true,\n    onError = (_a = globalThis.reportError) != null ? _a : noop\n  } = options;\n  const started = shallowRef(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  }, { flush });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((oldValue) => options(source, oldValue));\n  } else {\n    return computed({\n      get: (oldValue) => options.get(source, oldValue),\n      set: options.set\n    });\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createReusableTemplate(options = {}) {\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /*@__PURE__*/ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /*@__PURE__*/ defineComponent({\n    inheritAttrs,\n    props: options.props,\n    setup(props, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {\n          ...options.props == null ? keysToCamelKebabCase(attrs) : props,\n          $slots: slots\n        });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createTemplatePromise(options = {}) {\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /*@__PURE__*/ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nfunction useEventListener(...args) {\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options) => {\n    el.addEventListener(event, listener, options);\n    return () => el.removeEventListener(event, listener, options);\n  };\n  const firstParamTargets = computed(() => {\n    const test = toArray(toValue(args[0])).filter((e) => e != null);\n    return test.every((e) => typeof e !== \"string\") ? test : void 0;\n  });\n  const stopWatch = watchImmediate(\n    () => {\n      var _a, _b;\n      return [\n        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),\n        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),\n        toArray(unref(firstParamTargets.value ? args[2] : args[1])),\n        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains\n        toValue(firstParamTargets.value ? args[3] : args[2])\n      ];\n    },\n    ([raw_targets, raw_events, raw_listeners, raw_options]) => {\n      cleanup();\n      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))\n        return;\n      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;\n      cleanups.push(\n        ...raw_targets.flatMap(\n          (el) => raw_events.flatMap(\n            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))\n          )\n        )\n      );\n    },\n    { flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(cleanup);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;\n  if (!window) {\n    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;\n  }\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    const listenerOptions = { passive: true };\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop, listenerOptions));\n    window.document.documentElement.addEventListener(\"click\", noop, listenerOptions);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return toValue(ignore).some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  function hasMultipleRoots(target2) {\n    const vm = toValue(target2);\n    return vm && vm.$.subTree.shapeFlag === 16;\n  }\n  function checkMultipleRoots(target2, event) {\n    const vm = toValue(target2);\n    const children = vm.$.subTree && vm.$.subTree.children;\n    if (children == null || !Array.isArray(children))\n      return false;\n    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));\n  }\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (event.target == null)\n      return;\n    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))\n      return;\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (\"detail\" in event && event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  let isProcessingClick = false;\n  const cleanup = [\n    useEventListener(window, \"click\", (event) => {\n      if (!isProcessingClick) {\n        isProcessingClick = true;\n        setTimeout(() => {\n          isProcessingClick = false;\n        }, 0);\n        listener(event);\n      }\n    }, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    }, { passive: true })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  if (controls) {\n    return {\n      stop,\n      cancel: () => {\n        shouldListen = false;\n      },\n      trigger: (event) => {\n        shouldListen = true;\n        listener(event);\n        shouldListen = false;\n      }\n    };\n  }\n  return stop;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMounted() {\n  const isMounted = shallowRef(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, instance);\n  }\n  return isMounted;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = toArray(value).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    targets,\n    (newTargets) => {\n      cleanup();\n      if (isSupported.value && newTargets.size) {\n        observer = new MutationObserver(callback);\n        newTargets.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction onElementRemoval(target, callback, options = {}) {\n  const {\n    window = defaultWindow,\n    document = window == null ? void 0 : window.document,\n    flush = \"sync\"\n  } = options;\n  if (!window || !document)\n    return noop;\n  let stopFn;\n  const cleanupAndUpdate = (fn) => {\n    stopFn == null ? void 0 : stopFn();\n    stopFn = fn;\n  };\n  const stopWatch = watchEffect(() => {\n    const el = unrefElement(target);\n    if (el) {\n      const { stop } = useMutationObserver(\n        document,\n        (mutationsList) => {\n          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));\n          if (targetRemoved) {\n            callback(mutationsList);\n          }\n        },\n        {\n          window,\n          childList: true,\n          subtree: true\n        }\n      );\n      cleanupAndUpdate(stop);\n    }\n  }, { flush });\n  const stopHandle = () => {\n    stopWatch();\n    cleanupAndUpdate();\n  };\n  tryOnScopeDispose(stopHandle);\n  return stopHandle;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function getDelay(ev) {\n    const delay = options == null ? void 0 : options.delay;\n    if (typeof delay === \"function\") {\n      return delay(ev);\n    }\n    return delay != null ? delay : DEFAULT_DELAY;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      getDelay(ev)\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    if (!isFocusedElementEditable() && isTypedCharValid(event)) {\n      callback(event);\n    }\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = shallowRef();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    const listenerOptions = {\n      capture: true,\n      passive: true\n    };\n    useEventListener(\n      window,\n      \"blur\",\n      (event) => {\n        if (event.relatedTarget !== null)\n          return;\n        trigger();\n      },\n      listenerOptions\n    );\n    useEventListener(\n      window,\n      \"focus\",\n      trigger,\n      listenerOptions\n    );\n  }\n  if (triggerOnRemoval) {\n    onElementRemoval(activeElement, trigger, { document });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow,\n    once = false\n  } = options;\n  const isActive = shallowRef(false);\n  const intervalLimit = computed(() => {\n    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;\n  });\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit.value && delta < intervalLimit.value) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    if (once) {\n      isActive.value = false;\n      rafId = null;\n      return;\n    }\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    if (!animate.value)\n      update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    if (el) {\n      update(true);\n    } else {\n      animate.value = void 0;\n    }\n  });\n  watch(() => keyframes, (value) => {\n    if (animate.value) {\n      update();\n      const targetEl = unrefElement(target);\n      if (targetEl) {\n        animate.value.effect = new KeyframeEffect(\n          targetEl,\n          toValue(value),\n          animateOptions\n        );\n      }\n    }\n  }, { deep: true });\n  tryOnMounted(() => update(true), false);\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause, listenerOptions);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  }, listenerOptions);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = shallowRef(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        if (activeIndex.value === tasks.length - 1)\n          onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  var _a;\n  const {\n    immediate = true,\n    delay = 0,\n    onError = (_a = globalThis.reportError) != null ? _a : noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = shallowRef(false);\n  const isLoading = shallowRef(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = toValue(initialState);\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate) {\n    execute(delay);\n  }\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute,\n    executeImmediate: (...args) => execute(0, ...args)\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = shallowRef(\"\");\n  const promise = shallowRef();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => {\n      base64.value = (options == null ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, \"\") : res;\n    });\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = shallowRef(false);\n  const chargingTime = shallowRef(0);\n  const dischargingTime = shallowRef(0);\n  const level = shallowRef(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef();\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = shallowRef();\n  const isConnected = shallowRef(false);\n  function reset() {\n    isConnected.value = false;\n    device.value = void 0;\n    server.value = void 0;\n  }\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      useEventListener(device, \"gattserverdisconnected\", reset, { passive: true });\n      try {\n        server.value = await device.value.gatt.connect();\n        isConnected.value = server.value.connected;\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected: readonly(isConnected),\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nconst ssrWidthSymbol = Symbol(\"vueuse-ssr-width\");\n// @__NO_SIDE_EFFECTS__\nfunction useSSRWidth() {\n  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;\n  return typeof ssrWidth === \"number\" ? ssrWidth : void 0;\n}\nfunction provideSSRWidth(width, app) {\n  if (app !== void 0) {\n    app.provide(ssrWidthSymbol, width);\n  } else {\n    provideLocal(ssrWidthSymbol, width);\n  }\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow, ssrWidth = useSSRWidth() } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  const ssrSupport = shallowRef(typeof ssrWidth === \"number\");\n  const mediaQuery = shallowRef();\n  const matches = shallowRef(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  watchEffect(() => {\n    if (ssrSupport.value) {\n      ssrSupport.value = !isSupported.value;\n      const queryStrings = toValue(query).split(\",\");\n      matches.value = queryStrings.some((queryString) => {\n        const not = queryString.includes(\"not all\");\n        const minWidth = queryString.match(/\\(\\s*min-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n        const maxWidth = queryString.match(/\\(\\s*max-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n        let res = Boolean(minWidth || maxWidth);\n        if (minWidth && res) {\n          res = ssrWidth >= pxValue(minWidth[1]);\n        }\n        if (maxWidth && res) {\n          res = ssrWidth <= pxValue(maxWidth[1]);\n        }\n        return not ? !res : res;\n      });\n      return;\n    }\n    if (!isSupported.value)\n      return;\n    mediaQuery.value = window.matchMedia(toValue(query));\n    matches.value = mediaQuery.value.matches;\n  });\n  useEventListener(mediaQuery, \"change\", handler, { passive: true });\n  return computed(() => matches.value);\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\nconst breakpointsElement = {\n  xs: 0,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1920\n};\n\n// @__NO_SIDE_EFFECTS__\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\", ssrWidth = useSSRWidth() } = options;\n  const ssrSupport = typeof ssrWidth === \"number\";\n  const mounted = ssrSupport ? shallowRef(false) : { value: true };\n  if (ssrSupport) {\n    tryOnMounted(() => mounted.value = !!window);\n  }\n  function match(query, size) {\n    if (!mounted.value && ssrSupport) {\n      return query === \"min\" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);\n    }\n    if (!window)\n      return false;\n    return window.matchMedia(`(${query}-width: ${size})`).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((k) => [k, shortcutMethods[k], pxValue(getValue(k))]).sort((a, b) => a[2] - b[2]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(\"min\", getValue(k, 0.1));\n    },\n    isGreaterOrEqual(k) {\n      return match(\"min\", getValue(k));\n    },\n    isSmaller(k) {\n      return match(\"max\", getValue(k, -0.1));\n    },\n    isSmallerOrEqual(k) {\n      return match(\"max\", getValue(k));\n    },\n    isInBetween(a, b) {\n      return match(\"min\", getValue(a)) && match(\"max\", getValue(b, -0.1));\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(strategy === \"min-width\" ? -1 : 0));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = shallowRef(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      const listenerOptions = {\n        passive: true\n      };\n      useEventListener(channel, \"message\", (e) => {\n        data.value = e.data;\n      }, listenerOptions);\n      useEventListener(channel, \"messageerror\", (e) => {\n        error.value = e;\n      }, listenerOptions);\n      useEventListener(channel, \"close\", () => {\n        isClosed.value = true;\n      }, listenerOptions);\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\n// @__NO_SIDE_EFFECTS__\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref] of objectEntries(refs)) {\n    watch(ref, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    const listenerOptions = { passive: true };\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), listenerOptions);\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), listenerOptions);\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, options) {\n  const { deepRefs = true, ...watchOptions } = options || {};\n  const cachedValue = createRef(refValue.value, deepRefs);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  const permissionStatus = shallowRef();\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = shallowRef();\n  const update = () => {\n    var _a, _b;\n    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : \"prompt\";\n  };\n  useEventListener(permissionStatus, \"change\", update, { passive: true });\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus.value) {\n      try {\n        permissionStatus.value = await navigator.permissions.query(desc);\n      } catch (e) {\n        permissionStatus.value = void 0;\n      } finally {\n        update();\n      }\n    }\n    if (controls)\n      return toRaw(permissionStatus.value);\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = shallowRef(\"\");\n  const copied = shallowRef(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n  async function updateText() {\n    let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));\n    if (!useLegacy) {\n      try {\n        text.value = await navigator.clipboard.readText();\n      } catch (e) {\n        useLegacy = true;\n      }\n    }\n    if (useLegacy) {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText, { passive: true });\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));\n      if (!useLegacy) {\n        try {\n          await navigator.clipboard.writeText(value);\n        } catch (e) {\n          useLegacy = true;\n        }\n      }\n      if (useLegacy)\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = shallowRef(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read) {\n    useEventListener([\"copy\", \"cut\"], updateContent, { passive: true });\n  }\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content: shallowReadonly(content),\n    copied: readonly(copied),\n    copy,\n    read: updateContent\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const isModified = shallowRef(false);\n  let _lastSync = false;\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  watch(cloned, () => {\n    if (_lastSync) {\n      _lastSync = false;\n      return;\n    }\n    isModified.value = true;\n  }, {\n    deep: true,\n    flush: \"sync\"\n  });\n  function sync() {\n    _lastSync = true;\n    isModified.value = false;\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, isModified, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  const keyComputed = computed(() => toValue(key));\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    (newValue) => write(newValue),\n    { flush, deep, eventFilter }\n  );\n  watch(keyComputed, () => update(), { flush });\n  let firstMounted = false;\n  const onStorageEvent = (ev) => {\n    if (initOnMounted && !firstMounted) {\n      return;\n    }\n    update(ev);\n  };\n  const onStorageCustomEvent = (ev) => {\n    if (initOnMounted && !firstMounted) {\n      return;\n    }\n    updateFromCustomEvent(ev);\n  };\n  if (window && listenToStorageChanges) {\n    if (storage instanceof Storage)\n      useEventListener(window, \"storage\", onStorageEvent, { passive: true });\n    else\n      useEventListener(window, customStorageEventName, onStorageCustomEvent);\n  }\n  if (initOnMounted) {\n    tryOnMounted(() => {\n      firstMounted = true;\n      update();\n    });\n  } else {\n    update();\n  }\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      const payload = {\n        key: keyComputed.value,\n        oldValue,\n        newValue,\n        storageArea: storage\n      };\n      window.dispatchEvent(storage instanceof Storage ? new StorageEvent(\"storage\", payload) : new CustomEvent(customStorageEventName, {\n        detail: payload\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(keyComputed.value);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(keyComputed.value);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(keyComputed.value, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(keyComputed.value, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== keyComputed.value) {\n      return;\n    }\n    pauseWatch();\n    try {\n      const serializedData = serializer.write(data.value);\n      if (event === void 0 || (event == null ? void 0 : event.newValue) !== serializedData) {\n        data.value = read(event);\n      }\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nconst CSS_DISABLE_TRANS = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      const classesToAdd = /* @__PURE__ */ new Set();\n      const classesToRemove = /* @__PURE__ */ new Set();\n      let attributeToChange = null;\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            classesToAdd.add(v);\n          else\n            classesToRemove.add(v);\n        });\n      } else {\n        attributeToChange = { key: attribute2, value };\n      }\n      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));\n        window.document.head.appendChild(style);\n      }\n      for (const c of classesToAdd) {\n        el.classList.add(c);\n      }\n      for (const c of classesToRemove) {\n        el.classList.remove(c);\n      }\n      if (attributeToChange) {\n        el.setAttribute(attributeToChange.key, attributeToChange.value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  return Object.assign(auto, { store, system, state });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useConfirmDialog(revealed = shallowRef(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCountdown(initialCountdown, options) {\n  var _a, _b;\n  const remaining = shallowRef(toValue(initialCountdown));\n  const intervalController = useIntervalFn(() => {\n    var _a2, _b2;\n    const value = remaining.value - 1;\n    remaining.value = value < 0 ? 0 : value;\n    (_a2 = options == null ? void 0 : options.onTick) == null ? void 0 : _a2.call(options);\n    if (remaining.value <= 0) {\n      intervalController.pause();\n      (_b2 = options == null ? void 0 : options.onComplete) == null ? void 0 : _b2.call(options);\n    }\n  }, (_a = options == null ? void 0 : options.interval) != null ? _a : 1e3, { immediate: (_b = options == null ? void 0 : options.immediate) != null ? _b : false });\n  const reset = (countdown) => {\n    var _a2;\n    remaining.value = (_a2 = toValue(countdown)) != null ? _a2 : toValue(initialCountdown);\n  };\n  const stop = () => {\n    intervalController.pause();\n    reset();\n  };\n  const resume = () => {\n    if (!intervalController.isActive.value) {\n      if (remaining.value > 0) {\n        intervalController.resume();\n      }\n    }\n  };\n  const start = (countdown) => {\n    reset(countdown);\n    intervalController.resume();\n  };\n  return {\n    remaining,\n    reset,\n    stop,\n    start,\n    pause: intervalController.pause,\n    resume,\n    isActive: intervalController.isActive\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue, observe = false } = options;\n  const variable = shallowRef(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window && key) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || variable.value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    (_, old) => {\n      if (old[0] && old[1])\n        old[0].style.removeProperty(old[1]);\n      updateCssVar();\n    },\n    { immediate: true }\n  );\n  watch(\n    [variable, elRef],\n    ([val, el]) => {\n      const raw_prop = toValue(prop);\n      if ((el == null ? void 0 : el.style) && raw_prop) {\n        if (val == null)\n          el.style.removeProperty(raw_prop);\n        else\n          el.style.setProperty(raw_prop, val);\n      }\n    },\n    { immediate: true }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\"\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => mode.system.value);\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter,\n    shouldCommit = () => true\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  let lastRawValue = source.value;\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n      lastRawValue = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    if (!shouldCommit(lastRawValue, source.value))\n      return;\n    lastRawValue = source.value;\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions = false,\n    eventFilter = bypassFilter\n  } = options;\n  const isSupported = useSupported(() => typeof DeviceMotionEvent !== \"undefined\");\n  const requirePermissions = useSupported(() => isSupported.value && \"requestPermission\" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === \"function\");\n  const permissionGranted = shallowRef(false);\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = shallowRef(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  function init() {\n    if (window) {\n      const onDeviceMotion = createFilterWrapper(\n        eventFilter,\n        (event) => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n          acceleration.value = {\n            x: ((_a = event.acceleration) == null ? void 0 : _a.x) || null,\n            y: ((_b = event.acceleration) == null ? void 0 : _b.y) || null,\n            z: ((_c = event.acceleration) == null ? void 0 : _c.z) || null\n          };\n          accelerationIncludingGravity.value = {\n            x: ((_d = event.accelerationIncludingGravity) == null ? void 0 : _d.x) || null,\n            y: ((_e = event.accelerationIncludingGravity) == null ? void 0 : _e.y) || null,\n            z: ((_f = event.accelerationIncludingGravity) == null ? void 0 : _f.z) || null\n          };\n          rotationRate.value = {\n            alpha: ((_g = event.rotationRate) == null ? void 0 : _g.alpha) || null,\n            beta: ((_h = event.rotationRate) == null ? void 0 : _h.beta) || null,\n            gamma: ((_i = event.rotationRate) == null ? void 0 : _i.gamma) || null\n          };\n          interval.value = event.interval;\n        }\n      );\n      useEventListener(window, \"devicemotion\", onDeviceMotion, { passive: true });\n    }\n  }\n  const ensurePermissions = async () => {\n    if (!requirePermissions.value)\n      permissionGranted.value = true;\n    if (permissionGranted.value)\n      return;\n    if (requirePermissions.value) {\n      const requestPermission = DeviceMotionEvent.requestPermission;\n      try {\n        const response = await requestPermission();\n        if (response === \"granted\") {\n          permissionGranted.value = true;\n          init();\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n  if (isSupported.value) {\n    if (requestPermissions && requirePermissions.value) {\n      ensurePermissions().then(() => init());\n    } else {\n      init();\n    }\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval,\n    isSupported,\n    requirePermissions,\n    ensurePermissions,\n    permissionGranted\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = shallowRef(false);\n  const alpha = shallowRef(null);\n  const beta = shallowRef(null);\n  const gamma = shallowRef(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    }, { passive: true });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = shallowRef(1);\n  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);\n  let stop = noop;\n  if (window) {\n    stop = watchImmediate(query, () => pixelRatio.value = window.devicePixelRatio);\n  }\n  return {\n    pixelRatio: readonly(pixelRatio),\n    stop\n  };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = shallowRef(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    const deviceName = constraints.video ? \"camera\" : \"microphone\";\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(deviceName, { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      let granted = true;\n      try {\n        const allDevices = await navigator.mediaDevices.enumerateDevices();\n        const hasCamera = allDevices.some((device) => device.kind === \"videoinput\");\n        const hasMicrophone = allDevices.some((device) => device.kind === \"audioinput\" || device.kind === \"audiooutput\");\n        constraints.video = hasCamera ? constraints.video : false;\n        constraints.audio = hasMicrophone ? constraints.audio : false;\n        stream = await navigator.mediaDevices.getUserMedia(constraints);\n      } catch (e) {\n        stream = null;\n        granted = false;\n      }\n      update();\n      permissionGranted.value = granted;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update, { passive: true });\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => useEventListener(t, \"ended\", stop, { passive: true }));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return shallowRef(\"visible\");\n  const visibility = shallowRef(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  }, { passive: true });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target,\n    buttons = [0]\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!toValue(buttons).includes(e.button))\n      return;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = () => {\n      var _a2;\n      return {\n        capture: (_a2 = options.capture) != null ? _a2 : true,\n        passive: !toValue(preventDefault)\n      };\n    };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  var _a, _b;\n  const isOverDropZone = shallowRef(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isValid = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const multiple = (_a = _options.multiple) != null ? _a : true;\n    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;\n    const getFiles = (event) => {\n      var _a2, _b2;\n      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);\n      return list.length === 0 ? null : multiple ? list : [list[0]];\n    };\n    const checkDataTypes = (types) => {\n      const dataTypes = unref(_options.dataTypes);\n      if (typeof dataTypes === \"function\")\n        return dataTypes(types);\n      if (!(dataTypes == null ? void 0 : dataTypes.length))\n        return true;\n      if (types.length === 0)\n        return false;\n      return types.every(\n        (type) => dataTypes.some((allowedType) => type.includes(allowedType))\n      );\n    };\n    const checkValidity = (items) => {\n      const types = Array.from(items != null ? items : []).map((item) => item.type);\n      const dataTypesValid = checkDataTypes(types);\n      const multipleFilesValid = multiple || items.length <= 1;\n      return dataTypesValid && multipleFilesValid;\n    };\n    const isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !(\"chrome\" in window);\n    const handleDragEvent = (event, eventType) => {\n      var _a2, _b2, _c, _d, _e, _f;\n      const dataTransferItemList = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items;\n      isValid = (_b2 = dataTransferItemList && checkValidity(dataTransferItemList)) != null ? _b2 : false;\n      if (preventDefaultForUnhandled) {\n        event.preventDefault();\n      }\n      if (!isSafari() && !isValid) {\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = \"none\";\n        }\n        return;\n      }\n      event.preventDefault();\n      if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = \"copy\";\n      }\n      const currentFiles = getFiles(event);\n      switch (eventType) {\n        case \"enter\":\n          counter += 1;\n          isOverDropZone.value = true;\n          (_c = _options.onEnter) == null ? void 0 : _c.call(_options, null, event);\n          break;\n        case \"over\":\n          (_d = _options.onOver) == null ? void 0 : _d.call(_options, null, event);\n          break;\n        case \"leave\":\n          counter -= 1;\n          if (counter === 0)\n            isOverDropZone.value = false;\n          (_e = _options.onLeave) == null ? void 0 : _e.call(_options, null, event);\n          break;\n        case \"drop\":\n          counter = 0;\n          isOverDropZone.value = false;\n          if (isValid) {\n            files.value = currentFiles;\n            (_f = _options.onDrop) == null ? void 0 : _f.call(_options, currentFiles, event);\n          }\n          break;\n      }\n    };\n    useEventListener(target, \"dragenter\", (event) => handleDragEvent(event, \"enter\"));\n    useEventListener(target, \"dragover\", (event) => handleDragEvent(event, \"over\"));\n    useEventListener(target, \"dragleave\", (event) => handleDragEvent(event, \"leave\"));\n    useEventListener(target, \"drop\", (event) => handleDragEvent(event, \"drop\"));\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const _targets = toValue(target);\n    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];\n  });\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els) {\n          if (_el)\n            observer.observe(_el, observerOptions);\n        }\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true,\n    updateTiming = \"sync\"\n  } = options;\n  const height = shallowRef(0);\n  const bottom = shallowRef(0);\n  const left = shallowRef(0);\n  const right = shallowRef(0);\n  const top = shallowRef(0);\n  const width = shallowRef(0);\n  const x = shallowRef(0);\n  const y = shallowRef(0);\n  function recalculate() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  function update() {\n    if (updateTiming === \"sync\")\n      recalculate();\n    else if (updateTiming === \"next-frame\")\n      requestAnimationFrame(() => recalculate());\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = shallowRef(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    triggerOnRemoval = false,\n    window = defaultWindow\n  } = options;\n  const isHovered = shallowRef(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  if (triggerOnRemoval) {\n    onElementRemoval(\n      computed(() => unrefElement(el)),\n      () => toggle(false)\n    );\n  }\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = shallowRef(initialSize.width);\n  const height = shallowRef(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = toArray(boxSize);\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return toArray(_target).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = shallowRef(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const {\n    window = defaultWindow,\n    scrollTarget,\n    threshold = 0,\n    rootMargin,\n    once = false\n  } = options;\n  const elementIsVisible = shallowRef(false);\n  const { stop } = useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n      if (once) {\n        watchOnce(elementIsVisible, () => {\n          stop();\n        });\n      }\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold,\n      rootMargin: toValue(rootMargin)\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\n// @__NO_SIDE_EFFECTS__\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = shallowRef(null);\n  const data = shallowRef(null);\n  const status = shallowRef(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  const lastEventId = shallowRef(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true,\n    autoConnect = true,\n    autoReconnect,\n    serializer = {\n      read: (v) => v\n    }\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      var _a;\n      event.value = null;\n      data.value = (_a = serializer.read(e.data)) != null ? _a : null;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        var _a, _b;\n        event.value = event_name;\n        data.value = (_a = serializer.read(e.data)) != null ? _a : null;\n        lastEventId.value = (_b = e.lastEventId) != null ? _b : null;\n      }, { passive: true });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  if (autoConnect)\n    watch(urlRef, open);\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = shallowRef(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      let callback;\n      for (let i = callbacks.length - 1; i >= 0; i--) {\n        if (callbacks[i] != null) {\n          callback = callbacks[i];\n          break;\n        }\n      }\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a, _b;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_b = (_a = defaultWindow) == null ? void 0 : _a.fetch) != null ? _b : globalThis == null ? void 0 : globalThis.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = shallowRef(false);\n  const isFetching = shallowRef(false);\n  const aborted = shallowRef(false);\n  const statusCode = shallowRef(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = (reason) => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort(reason);\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b2;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    const payload = toValue(config.payload);\n    if (payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const proto = Object.getPrototypeOf(payload);\n      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b2 = context.options) == null ? void 0 : _b2.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse,\n          context,\n          execute\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value,\n          context,\n          execute\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\")) {\n    return `${start}/${end}`;\n  }\n  if (start.endsWith(\"/\") && end.startsWith(\"/\")) {\n    return `${start.slice(0, -1)}${end}`;\n  }\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction prepareInitialFiles(files) {\n  if (!files)\n    return null;\n  if (files instanceof FileList)\n    return files;\n  const dt = new DataTransfer();\n  for (const file of files) {\n    dt.items.add(file);\n  }\n  return dt.files;\n}\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(prepareInitialFiles(options.initialFiles));\n  const { on: onChange, trigger: changeTrigger } = createEventHook();\n  const { on: onCancel, trigger: cancelTrigger } = createEventHook();\n  const inputRef = computed(() => {\n    var _a;\n    const input = (_a = unrefElement(options.input)) != null ? _a : document ? document.createElement(\"input\") : void 0;\n    if (input) {\n      input.type = \"file\";\n      input.onchange = (event) => {\n        const result = event.target;\n        files.value = result.files;\n        changeTrigger(files.value);\n      };\n      input.oncancel = () => {\n        cancelTrigger();\n      };\n    }\n    return input;\n  });\n  const reset = () => {\n    files.value = null;\n    if (inputRef.value && inputRef.value.value) {\n      inputRef.value.value = \"\";\n      changeTrigger(null);\n    }\n  };\n  const applyOptions = (options2) => {\n    const el = inputRef.value;\n    if (!el)\n      return;\n    el.multiple = toValue(options2.multiple);\n    el.accept = toValue(options2.accept);\n    el.webkitdirectory = toValue(options2.directory);\n    if (hasOwn(options2, \"capture\"))\n      el.capture = toValue(options2.capture);\n  };\n  const open = (localOptions) => {\n    const el = inputRef.value;\n    if (!el)\n      return;\n    const mergedOptions = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    applyOptions(mergedOptions);\n    if (toValue(mergedOptions.reset))\n      reset();\n    el.click();\n  };\n  watchEffect(() => {\n    applyOptions(options);\n  });\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onCancel,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = shallowRef();\n  const data = shallowRef();\n  const file = shallowRef();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = shallowRef(false);\n  const targetElement = computed(() => unrefElement(target));\n  const listenerOptions = { passive: true };\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  }, listenerOptions);\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false, listenerOptions);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nconst EVENT_FOCUS_IN = \"focusin\";\nconst EVENT_FOCUS_OUT = \"focusout\";\nconst PSEUDO_CLASS_FOCUS_WITHIN = \":focus-within\";\nfunction useFocusWithin(target, options = {}) {\n  const { window = defaultWindow } = options;\n  const targetElement = computed(() => unrefElement(target));\n  const _focused = shallowRef(false);\n  const focused = computed(() => _focused.value);\n  const activeElement = useActiveElement(options);\n  if (!window || !activeElement.value) {\n    return { focused };\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);\n  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {\n    var _a, _b, _c;\n    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;\n  }, listenerOptions);\n  return { focused };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useFps(options) {\n  var _a;\n  const fps = shallowRef(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.documentElement;\n  });\n  const isFullscreen = shallowRef(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  const listenerOptions = { capture: false, passive: true };\n  useEventListener(document, eventHandlers, handlerCallback, listenerOptions);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);\n  tryOnMounted(handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\n// @__NO_SIDE_EFFECTS__\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  const listenerOptions = { passive: true };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad), listenerOptions);\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = shallowRef(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = shallowRef(initialState);\n  const lastActive = shallowRef(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    const listenerOptions = { passive: true };\n    for (const event of events)\n      useEventListener(window, event, onEvent, listenerOptions);\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      }, listenerOptions);\n    }\n    if (!initialState)\n      reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;\n    img.src = src;\n    if (srcset != null)\n      img.srcset = srcset;\n    if (sizes != null)\n      img.sizes = sizes;\n    if (clazz != null)\n      img.className = clazz;\n    if (loading != null)\n      img.loading = loading;\n    if (crossorigin != null)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy != null)\n      img.referrerPolicy = referrerPolicy;\n    if (width != null)\n      img.width = width;\n    if (height != null)\n      img.height = height;\n    if (decoding != null)\n      img.decoding = decoding;\n    if (fetchPriority != null)\n      img.fetchPriority = fetchPriority;\n    if (ismap != null)\n      img.isMap = ismap;\n    if (usemap != null)\n      img.useMap = usemap;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    observe: _observe = {\n      mutation: false\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const observe = typeof _observe === \"boolean\" ? {\n    mutation: _observe\n  } : _observe;\n  const internalX = shallowRef(0);\n  const internalY = shallowRef(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = shallowRef(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection, direction } = getComputedStyle(el);\n    const directionMultipler = direction === \"rtl\" ? -1 : 1;\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  if ((observe == null ? void 0 : observe.mutation) && element != null && element !== window && element !== document) {\n    useMutationObserver(\n      element,\n      () => {\n        const _element = toValue(element);\n        if (!_element)\n          return;\n        setArrivedState(_element);\n      },\n      {\n        attributes: true,\n        childList: true,\n        subtree: true\n      }\n    );\n  }\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  const stop = watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  tryOnUnmounted(stop);\n  return {\n    isLoading,\n    reset() {\n      nextTick(() => checkAndLoad());\n    }\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\n// @__NO_SIDE_EFFECTS__\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = shallowRef(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      }, { passive: true });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const shiftDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"shift\" && !value) {\n      const shiftDepsArray = Array.from(shiftDeps);\n      const shiftIndex = shiftDepsArray.indexOf(\"shift\");\n      shiftDepsArray.forEach((key2, index) => {\n        if (index >= shiftIndex) {\n          current.delete(key2);\n          setRefs(key2, false);\n        }\n      });\n      shiftDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Shift\") && value) {\n      [...current, ...values].forEach((key2) => shiftDeps.add(key2));\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive });\n  useEventListener(\"focus\", reset, { passive });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.map((key) => toValue(proxy[key])).every(Boolean));\n          } else {\n            refs[prop] = shallowRef(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = toRef(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const listenerOptions = { passive: true };\n  const currentTime = shallowRef(0);\n  const duration = shallowRef(0);\n  const seeking = shallowRef(false);\n  const volume = shallowRef(1);\n  const waiting = shallowRef(false);\n  const ended = shallowRef(false);\n  const playing = shallowRef(false);\n  const rate = shallowRef(1);\n  const stalled = shallowRef(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = shallowRef(-1);\n  const isPictureInPicture = shallowRef(false);\n  const muted = shallowRef(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const playbackErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type, media }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.setAttribute(\"media\", media || \"\");\n      useEventListener(source, \"error\", sourceErrorEvent.trigger, listenerOptions);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    if (isPlaying) {\n      el.play().catch((e) => {\n        playbackErrorEvent.trigger(e);\n        throw e;\n      });\n    } else {\n      el.pause();\n    }\n  });\n  useEventListener(\n    target,\n    \"timeupdate\",\n    () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"durationchange\",\n    () => duration.value = toValue(target).duration,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"progress\",\n    () => buffered.value = timeRangeToArray(toValue(target).buffered),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"seeking\",\n    () => seeking.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"seeked\",\n    () => seeking.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    [\"waiting\", \"loadstart\"],\n    () => {\n      waiting.value = true;\n      ignorePlayingUpdates(() => playing.value = false);\n    },\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"loadeddata\",\n    () => waiting.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"playing\",\n    () => {\n      waiting.value = false;\n      ended.value = false;\n      ignorePlayingUpdates(() => playing.value = true);\n    },\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"ratechange\",\n    () => rate.value = toValue(target).playbackRate,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"stalled\",\n    () => stalled.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"ended\",\n    () => ended.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"pause\",\n    () => ignorePlayingUpdates(() => playing.value = false),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"play\",\n    () => ignorePlayingUpdates(() => playing.value = true),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"enterpictureinpicture\",\n    () => isPictureInPicture.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"leavepictureinpicture\",\n    () => isPictureInPicture.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"volumechange\",\n    () => {\n      const el = toValue(target);\n      if (!el)\n        return;\n      volume.value = el.volume;\n      muted.value = el.muted;\n    },\n    listenerOptions\n  );\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on,\n    onPlaybackError: playbackErrorEvent.on\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  let _prevScrollX = 0;\n  let _prevScrollY = 0;\n  const x = shallowRef(initialValue.x);\n  const y = shallowRef(initialValue.y);\n  const sourceType = shallowRef(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n    if (window) {\n      _prevScrollX = window.scrollX;\n      _prevScrollY = window.scrollY;\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX - _prevScrollX;\n      y.value = pos[1] + window.scrollY - _prevScrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, listenerOptions);\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    windowResize = true,\n    windowScroll = true,\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = shallowRef(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = shallowRef(0);\n  const elementY = shallowRef(0);\n  const elementPositionX = shallowRef(0);\n  const elementPositionY = shallowRef(0);\n  const elementHeight = shallowRef(0);\n  const elementWidth = shallowRef(0);\n  const isOutside = shallowRef(true);\n  function update() {\n    if (!window)\n      return;\n    const el = unrefElement(targetRef);\n    if (!el || !(el instanceof Element))\n      return;\n    const {\n      left,\n      top,\n      width,\n      height\n    } = el.getBoundingClientRect();\n    elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n    elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n    elementHeight.value = height;\n    elementWidth.value = width;\n    const elX = x.value - elementPositionX.value;\n    const elY = y.value - elementPositionY.value;\n    isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n    if (handleOutside || !isOutside.value) {\n      elementX.value = elX;\n      elementY.value = elY;\n    }\n  }\n  const stopFnList = [];\n  function stop() {\n    stopFnList.forEach((fn) => fn());\n    stopFnList.length = 0;\n  }\n  tryOnMounted(() => {\n    update();\n  });\n  if (window) {\n    const {\n      stop: stopResizeObserver\n    } = useResizeObserver(targetRef, update);\n    const {\n      stop: stopMutationObserver\n    } = useMutationObserver(targetRef, update, {\n      attributeFilter: [\"style\", \"class\"]\n    });\n    const stopWatch = watch(\n      [targetRef, x, y],\n      update\n    );\n    stopFnList.push(\n      stopResizeObserver,\n      stopMutationObserver,\n      stopWatch\n    );\n    useEventListener(\n      document,\n      \"mouseleave\",\n      () => isOutside.value = true,\n      { passive: true }\n    );\n    if (windowScroll) {\n      stopFnList.push(\n        useEventListener(\"scroll\", update, { capture: true, passive: true })\n      );\n    }\n    if (windowResize) {\n      stopFnList.push(\n        useEventListener(\"resize\", update, { passive: true })\n      );\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = shallowRef(initialValue);\n  const sourceType = shallowRef(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => (event) => {\n    var _a;\n    pressed.value = true;\n    sourceType.value = srcType;\n    (_a = options.onPressed) == null ? void 0 : _a.call(options, event);\n  };\n  const onReleased = (event) => {\n    var _a;\n    pressed.value = false;\n    sourceType.value = null;\n    (_a = options.onReleased) == null ? void 0 : _a.call(options, event);\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  const listenerOptions = { passive: true, capture };\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), listenerOptions);\n  useEventListener(window, \"mouseleave\", onReleased, listenerOptions);\n  useEventListener(window, \"mouseup\", onReleased, listenerOptions);\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), listenerOptions);\n    useEventListener(window, \"drop\", onReleased, listenerOptions);\n    useEventListener(window, \"dragend\", onReleased, listenerOptions);\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), listenerOptions);\n    useEventListener(window, \"touchend\", onReleased, listenerOptions);\n    useEventListener(window, \"touchcancel\", onReleased, listenerOptions);\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = shallowRef(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  }, { passive: true });\n  return {\n    isSupported,\n    language\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = shallowRef(true);\n  const saveData = shallowRef(false);\n  const offlineAt = shallowRef(void 0);\n  const onlineAt = shallowRef(void 0);\n  const downlink = shallowRef(void 0);\n  const downlinkMax = shallowRef(void 0);\n  const rtt = shallowRef(void 0);\n  const effectiveType = shallowRef(void 0);\n  const type = shallowRef(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  const listenerOptions = { passive: true };\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    }, listenerOptions);\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    }, listenerOptions);\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, listenerOptions);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline: readonly(isOnline),\n    saveData: readonly(saveData),\n    offlineAt: readonly(offlineAt),\n    onlineAt: readonly(onlineAt),\n    downlink: readonly(downlink),\n    downlinkMax: readonly(downlinkMax),\n    effectiveType: readonly(effectiveType),\n    rtt: readonly(rtt),\n    type: readonly(type)\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval, { immediate });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = shallowRef();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = shallowRef(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    const listenerOptions = { passive: true };\n    useEventListener(window, \"mouseout\", handler, listenerOptions);\n    useEventListener(window.document, \"mouseleave\", handler, listenerOptions);\n    useEventListener(window.document, \"mouseenter\", handler, listenerOptions);\n  }\n  return isLeft;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = shallowRef(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    }, { passive: true });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = shallowRef(false);\n  const state = shallowRef(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = shallowRef();\n  const triggerElement = shallowRef();\n  let targetElement;\n  if (isSupported.value) {\n    const listenerOptions = { passive: true };\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    }, listenerOptions);\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    }, listenerOptions);\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = shallowRef(false);\n  const isPointerDown = shallowRef(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const listenerOptions = { passive: true };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    }, listenerOptions)\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"pan-y\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return shallowRef([\"en\"]);\n  const navigator = window.navigator;\n  const value = shallowRef(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  }, { passive: true });\n  return value;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredReducedTransparency(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-transparency: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = shallowRef(\"\");\n  const right = shallowRef(\"\");\n  const bottom = shallowRef(\"\");\n  const left = shallowRef(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    tryOnMounted(update);\n    useEventListener(\"resize\", useDebounceFn(update), { passive: true });\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {},\n    nonce = void 0\n  } = options;\n  const scriptTag = shallowRef(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      if (nonce) {\n        el.nonce = nonce;\n      }\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    const listenerOptions = {\n      passive: true\n    };\n    useEventListener(el, \"error\", (event) => reject(event), listenerOptions);\n    useEventListener(el, \"abort\", (event) => reject(event), listenerOptions);\n    useEventListener(el, \"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    }, listenerOptions);\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = shallowRef(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    if (isIOS)\n      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    maxAlternatives = 1,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = shallowRef(false);\n  const isFinal = shallowRef(false);\n  const result = shallowRef(\"\");\n  const error = shallowRef(void 0);\n  let recognition;\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const toggle = (value = !isListening.value) => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.maxAlternatives = maxAlternatives;\n    recognition.onstart = () => {\n      isListening.value = true;\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, (newValue, oldValue) => {\n      if (newValue === oldValue)\n        return;\n      if (newValue)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow,\n    onBoundary\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = shallowRef(false);\n  const status = shallowRef(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = toValue(volume);\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n    utterance2.onboundary = (event) => {\n      onBoundary == null ? void 0 : onBoundary(event);\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    if (utterance)\n      synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    onReady\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(toValue(initialValue));\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  const promise = new Promise((resolve) => {\n    read().then(() => {\n      onReady == null ? void 0 : onReady(data.value);\n      resolve(data);\n    });\n  });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)), { passive: true });\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  Object.assign(data, {\n    then: promise.then.bind(promise),\n    catch: promise.catch.bind(promise)\n  });\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = shallowRef(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = shallowRef(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.nonce)\n        el.nonce = options.nonce;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = shallowRef(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  const listenerOptions = { passive, capture: !passive };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))\n        e.preventDefault();\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop,\n    // TODO: Remove in the next major version\n    isPassiveEventSupported: true\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\n// @__NO_SIDE_EFFECTS__\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange, { passive: true });\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction tryRequestAnimationFrame(window = defaultWindow, fn) {\n  if (window && typeof window.requestAnimationFrame === \"function\") {\n    window.requestAnimationFrame(fn);\n  } else {\n    fn();\n  }\n}\nfunction useTextareaAutosize(options = {}) {\n  var _a, _b;\n  const { window = defaultWindow } = options;\n  const textarea = toRef(options == null ? void 0 : options.element);\n  const input = toRef((_a = options == null ? void 0 : options.input) != null ? _a : \"\");\n  const styleProp = (_b = options == null ? void 0 : options.styleProp) != null ? _b : \"height\";\n  const textareaScrollHeight = shallowRef(1);\n  const textareaOldWidth = shallowRef(0);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);\n    if (_styleTarget)\n      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  watch(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, ([{ contentRect }]) => {\n    if (textareaOldWidth.value === contentRect.width)\n      return;\n    tryRequestAnimationFrame(window, () => {\n      textareaOldWidth.value = contentRect.width;\n      triggerResize();\n    });\n  });\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nconst UNITS = [\n  { name: \"year\", ms: 31536e6 },\n  { name: \"month\", ms: 2592e6 },\n  { name: \"week\", ms: 6048e5 },\n  { name: \"day\", ms: 864e5 },\n  { name: \"hour\", ms: 36e5 },\n  { name: \"minute\", ms: 6e4 },\n  { name: \"second\", ms: 1e3 }\n];\nfunction useTimeAgoIntl(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const result = computed(\n    () => getTimeAgoIntlResult(new Date(toValue(time)), options, toValue(now))\n  );\n  const parts = computed(() => result.value.parts);\n  const timeAgoIntl = computed(\n    () => formatTimeAgoIntlParts(parts.value, {\n      ...options,\n      locale: result.value.resolvedLocale\n    })\n  );\n  return exposeControls ? { timeAgoIntl, parts, ...controls } : timeAgoIntl;\n}\nfunction formatTimeAgoIntl(from, options = {}, now = Date.now()) {\n  const { parts, resolvedLocale } = getTimeAgoIntlResult(from, options, now);\n  return formatTimeAgoIntlParts(parts, {\n    ...options,\n    locale: resolvedLocale\n  });\n}\nfunction getTimeAgoIntlResult(from, options = {}, now = Date.now()) {\n  const {\n    locale,\n    relativeTimeFormatOptions = { numeric: \"auto\" }\n  } = options;\n  const rtf = new Intl.RelativeTimeFormat(locale, relativeTimeFormatOptions);\n  const { locale: resolvedLocale } = rtf.resolvedOptions();\n  const diff = +from - +now;\n  const absDiff = Math.abs(diff);\n  for (const { name, ms } of UNITS) {\n    if (absDiff >= ms) {\n      return {\n        resolvedLocale,\n        parts: rtf.formatToParts(Math.round(diff / ms), name)\n      };\n    }\n  }\n  return {\n    resolvedLocale,\n    parts: rtf.formatToParts(0, \"second\")\n  };\n}\nfunction formatTimeAgoIntlParts(parts, options = {}) {\n  const {\n    insertSpace = true,\n    joinParts,\n    locale\n  } = options;\n  if (typeof joinParts === \"function\")\n    return joinParts(parts, locale);\n  if (!insertSpace)\n    return parts.map((part) => part.value).join(\"\");\n  return parts.map((part) => part.value.trim()).join(\" \");\n}\n\nfunction useTimeoutPoll(fn, interval, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  const { start } = useTimeoutFn(loop, interval, { immediate });\n  const isActive = shallowRef(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      if (immediateCallback)\n        fn();\n      start();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (immediate && isClient)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = shallowRef(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = !!(newTitle && typeof newTitle === \"function\");\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (newValue, oldValue) => {\n      if (newValue !== oldValue && document)\n        document.title = format(newValue != null ? newValue : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnScopeDispose(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const {\n    window = defaultWindow\n  } = options;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        window == null ? void 0 : window.requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    writeMode = \"replace\",\n    window = defaultWindow,\n    stringify = (params) => params.toString()\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = stringify(params);\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${window.location.search || \"\"}${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${window.location.search || \"\"}${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params, false);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate, shouldWriteHistory = true) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    if (writeMode === \"replace\") {\n      window.history.replaceState(\n        window.history.state,\n        window.document.title,\n        window.location.pathname + constructQuery(params)\n      );\n    } else {\n      if (shouldWriteHistory) {\n        window.history.pushState(\n          window.history.state,\n          window.document.title,\n          window.location.pathname + constructQuery(params)\n        );\n      }\n    }\n    nextTick(() => resume());\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true, false);\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(window, \"popstate\", onChanged, listenerOptions);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, listenerOptions);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = shallowRef((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    key = \"modelValue\";\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = shallowRef(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  watch([size.width, size.height, () => toValue(list), containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  const requestedType = shallowRef(false);\n  const sentinel = shallowRef(null);\n  const documentVisibility = useDocumentVisibility({ document });\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = computed(() => !!sentinel.value && documentVisibility.value === \"visible\");\n  if (isSupported.value) {\n    useEventListener(sentinel, \"release\", () => {\n      var _a, _b;\n      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;\n    }, { passive: true });\n    whenever(\n      () => documentVisibility.value === \"visible\" && (document == null ? void 0 : document.visibilityState) === \"visible\" && requestedType.value,\n      (type) => {\n        requestedType.value = false;\n        forceRequest(type);\n      }\n    );\n  }\n  async function forceRequest(type) {\n    var _a;\n    await ((_a = sentinel.value) == null ? void 0 : _a.release());\n    sentinel.value = isSupported.value ? await navigator.wakeLock.request(type) : null;\n  }\n  async function request(type) {\n    if (documentVisibility.value === \"visible\")\n      await forceRequest(type);\n    else\n      requestedType.value = type;\n  }\n  async function release() {\n    requestedType.value = false;\n    const s = sentinel.value;\n    sentinel.value = null;\n    await (s == null ? void 0 : s.release());\n  }\n  return {\n    sentinel,\n    isSupported,\n    isActive,\n    request,\n    forceRequest,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    if (Notification.permission === \"granted\")\n      return true;\n    try {\n      const notification2 = new Notification(\"\");\n      notification2.onshow = () => {\n        notification2.close();\n      };\n    } catch (e) {\n      if (e.name === \"TypeError\")\n        return false;\n    }\n    return true;\n  });\n  const permissionGranted = shallowRef(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoConnect = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = shallowRef(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let retryTimeout;\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetRetry = () => {\n    if (retryTimeout != null) {\n      clearTimeout(retryTimeout);\n      retryTimeout = void 0;\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    resetRetry();\n    if (!isClient && !isWorker || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      retried = 0;\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      resetHeartbeat();\n      heartbeatPause == null ? void 0 : heartbeatPause();\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        const checkRetires = typeof retries === \"function\" ? retries : () => typeof retries === \"number\" && (retries < 0 || retried < retries);\n        if (checkRetires(retried)) {\n          retried += 1;\n          retryTimeout = setTimeout(_init, delay);\n        } else {\n          onFailed == null ? void 0 : onFailed();\n        }\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE,\n          responseMessage = message\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === toValue(responseMessage))\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(toValue(message), false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close(), { passive: true });\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  if (autoConnect)\n    watch(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = shallowRef(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = shallowRef();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    var _a;\n    promise.value = {\n      resolve,\n      reject\n    };\n    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return shallowRef(false);\n  const focused = shallowRef(window.document.hasFocus());\n  const listenerOptions = { passive: true };\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  }, listenerOptions);\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  }, listenerOptions);\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, ...rest } = options;\n  return useScroll(window, rest);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true,\n    type = \"inner\"\n  } = options;\n  const width = shallowRef(initialWidth);\n  const height = shallowRef(initialHeight);\n  const update = () => {\n    if (window) {\n      if (type === \"outer\") {\n        width.value = window.outerWidth;\n        height.value = window.outerHeight;\n      } else if (type === \"visual\" && window.visualViewport) {\n        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window.visualViewport;\n        width.value = Math.round(visualViewportWidth * scale);\n        height.value = Math.round(visualViewportHeight * scale);\n      } else if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  const listenerOptions = { passive: true };\n  useEventListener(\"resize\", update, listenerOptions);\n  if (window && type === \"visual\" && window.visualViewport) {\n    useEventListener(window.visualViewport, \"resize\", update, listenerOptions);\n  }\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, formatTimeAgoIntl, formatTimeAgoIntlParts, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeAgoIntl, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import { defineComponent as _defineComponent } from 'vue';\nimport { unref as _unref, createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, isRef as _isRef, vModelSelect as _vModelSelect, withDirectives as _withDirectives, vModelText as _vModelText, renderList as _renderList, Fragment as _Fragment, withModifiers as _withModifiers, withKeys as _withKeys } from \"vue\";\nconst _hoisted_1 = {\n    key: 0,\n    class: \"create-flow\"\n};\nconst _hoisted_2 = {\n    key: 0,\n    class: \"cover-panel\"\n};\nconst _hoisted_3 = { class: \"cover-actions\" };\nconst _hoisted_4 = {\n    key: 1,\n    class: \"create-panel\"\n};\nconst _hoisted_5 = {\n    key: 0,\n    class: \"xeno-route-box\"\n};\nconst _hoisted_6 = { class: \"field\" };\nconst _hoisted_7 = { class: \"field\" };\nconst _hoisted_8 = {\n    key: 1,\n    class: \"field\"\n};\nconst _hoisted_9 = {\n    key: 2,\n    class: \"tip profession-mark\"\n};\nconst _hoisted_10 = {\n    key: 3,\n    class: \"field\"\n};\nconst _hoisted_11 = [\"value\"];\nconst _hoisted_12 = { class: \"field\" };\nconst _hoisted_13 = [\"min\", \"max\"];\nconst _hoisted_14 = { class: \"field\" };\nconst _hoisted_15 = [\"disabled\"];\nconst _hoisted_16 = {\n    key: 4,\n    class: \"tip\"\n};\nconst _hoisted_17 = { class: \"age-tip\" };\nconst _hoisted_18 = {\n    key: 5,\n    class: \"error\"\n};\nconst _hoisted_19 = { class: \"actions\" };\nconst _hoisted_20 = {\n    key: 2,\n    class: \"create-panel\"\n};\nconst _hoisted_21 = { class: \"tip strong\" };\nconst _hoisted_22 = { class: \"allocate-list\" };\nconst _hoisted_23 = { class: \"human-attr-meta\" };\nconst _hoisted_24 = { class: \"human-attr-desc\" };\nconst _hoisted_25 = { class: \"counter\" };\nconst _hoisted_26 = [\"onClick\"];\nconst _hoisted_27 = [\"onClick\"];\nconst _hoisted_28 = { class: \"human-attr-help\" };\nconst _hoisted_29 = { class: \"human-attr-help-list\" };\nconst _hoisted_30 = {\n    key: 0,\n    class: \"error\"\n};\nconst _hoisted_31 = { class: \"actions\" };\nconst _hoisted_32 = {\n    key: 3,\n    class: \"create-panel\"\n};\nconst _hoisted_33 = { class: \"tip\" };\nconst _hoisted_34 = { class: \"tip profession-mark\" };\nconst _hoisted_35 = { class: \"tip strong\" };\nconst _hoisted_36 = { class: \"ability-list\" };\nconst _hoisted_37 = [\"onClick\"];\nconst _hoisted_38 = { class: \"ability-source\" };\nconst _hoisted_39 = {\n    key: 0,\n    class: \"error\"\n};\nconst _hoisted_40 = { class: \"actions\" };\nconst _hoisted_41 = {\n    key: 4,\n    class: \"create-panel\"\n};\nconst _hoisted_42 = { class: \"tip profession-mark\" };\nconst _hoisted_43 = { class: \"tip\" };\nconst _hoisted_44 = { class: \"skill-list\" };\nconst _hoisted_45 = [\"onClick\"];\nconst _hoisted_46 = {\n    key: 0,\n    class: \"ability-source\"\n};\nconst _hoisted_47 = {\n    key: 0,\n    class: \"field\"\n};\nconst _hoisted_48 = { class: \"field\" };\nconst _hoisted_49 = [\"value\"];\nconst _hoisted_50 = { class: \"field\" };\nconst _hoisted_51 = { class: \"field\" };\nconst _hoisted_52 = {\n    key: 2,\n    class: \"tip\"\n};\nconst _hoisted_53 = {\n    key: 3,\n    class: \"error\"\n};\nconst _hoisted_54 = { class: \"actions\" };\nconst _hoisted_55 = {\n    key: 5,\n    class: \"create-panel\"\n};\nconst _hoisted_56 = { class: \"background-template-box\" };\nconst _hoisted_57 = { class: \"background-template-actions\" };\nconst _hoisted_58 = { class: \"example-box background-template-preview\" };\nconst _hoisted_59 = { class: \"field\" };\nconst _hoisted_60 = { class: \"tip\" };\nconst _hoisted_61 = {\n    key: 0,\n    class: \"field\"\n};\nconst _hoisted_62 = {\n    key: 1,\n    class: \"error\"\n};\nconst _hoisted_63 = { class: \"actions\" };\nconst _hoisted_64 = {\n    key: 6,\n    class: \"create-panel\"\n};\nconst _hoisted_65 = { class: \"tip\" };\nconst _hoisted_66 = { class: \"dice-rule-list\" };\nconst _hoisted_67 = {\n    key: 0,\n    class: \"dice-result-list\"\n};\nconst _hoisted_68 = {\n    key: 1,\n    class: \"error\"\n};\nconst _hoisted_69 = { class: \"actions\" };\nconst _hoisted_70 = { class: \"mvu-toolbar\" };\nconst _hoisted_71 = { class: \"mvu-toolbar-actions\" };\nconst _hoisted_72 = { class: \"mvu-font-tools\" };\nconst _hoisted_73 = [\"onClick\"];\nconst _hoisted_74 = {\n    key: 1,\n    class: \"empty-tip\"\n};\nconst _hoisted_75 = { class: \"next-actions-head\" };\nconst _hoisted_76 = {\n    key: 0,\n    class: \"next-actions-grid\"\n};\nconst _hoisted_77 = [\"onClick\"];\nconst _hoisted_78 = {\n    key: 1,\n    class: \"next-actions-inputbox\"\n};\nconst _hoisted_79 = [\"onKeydown\"];\nconst _hoisted_80 = { class: \"next-actions-input-actions\" };\nconst _hoisted_81 = [\"disabled\"];\nconst _hoisted_82 = {\n    key: 0,\n    class: \"gameover-banner\"\n};\nconst _hoisted_83 = {\n    key: 1,\n    class: \"status-collapsed-banner\"\n};\nconst _hoisted_84 = { class: \"hero\" };\nconst _hoisted_85 = { class: \"hero-controls\" };\nconst _hoisted_86 = { class: \"threat\" };\nconst _hoisted_87 = { class: \"world\" };\nconst _hoisted_88 = { class: \"tabs\" };\nconst _hoisted_89 = {\n    key: 0,\n    class: \"panel\"\n};\nconst _hoisted_90 = { class: \"bars\" };\nconst _hoisted_91 = { class: \"bar\" };\nconst _hoisted_92 = [\"value\", \"max\"];\nconst _hoisted_93 = { class: \"bar-value\" };\nconst _hoisted_94 = { class: \"bar\" };\nconst _hoisted_95 = [\"value\", \"max\"];\nconst _hoisted_96 = { class: \"bar-value\" };\nconst _hoisted_97 = { class: \"bar\" };\nconst _hoisted_98 = [\"value\"];\nconst _hoisted_99 = { class: \"bar-value\" };\nconst _hoisted_100 = { class: \"grid two\" };\nconst _hoisted_101 = { class: \"kv\" };\nconst _hoisted_102 = { key: 0 };\nconst _hoisted_103 = { class: \"kv\" };\nconst _hoisted_104 = { class: \"grid two\" };\nconst _hoisted_105 = { class: \"big\" };\nconst _hoisted_106 = { key: 0 };\nconst _hoisted_107 = { key: 0 };\nconst _hoisted_108 = {\n    key: 1,\n    class: \"panel\"\n};\nconst _hoisted_109 = { class: \"grid two\" };\nconst _hoisted_110 = { key: 0 };\nconst _hoisted_111 = { key: 0 };\nconst _hoisted_112 = {\n    key: 1,\n    class: \"kv\"\n};\nconst _hoisted_113 = {\n    key: 0,\n    class: \"air-menu\"\n};\nconst _hoisted_114 = { key: 0 };\nconst _hoisted_115 = {\n    key: 1,\n    class: \"loot\"\n};\nconst _hoisted_116 = { key: 0 };\nconst _hoisted_117 = {\n    key: 1,\n    class: \"kv\"\n};\nconst _hoisted_118 = {\n    key: 2,\n    class: \"panel\"\n};\nconst _hoisted_119 = { key: 0 };\nconst _hoisted_120 = {\n    key: 1,\n    class: \"kv\"\n};\nconst _hoisted_121 = { key: 0 };\nconst _hoisted_122 = {\n    key: 1,\n    class: \"kv\"\n};\nconst _hoisted_123 = {\n    key: 3,\n    class: \"panel\"\n};\nconst _hoisted_124 = { class: \"grid two\" };\nconst _hoisted_125 = { key: 0 };\nconst _hoisted_126 = { key: 0 };\nconst _hoisted_127 = {\n    key: 1,\n    class: \"kv\"\n};\nconst _hoisted_128 = [\"onClick\"];\nconst _hoisted_129 = { class: \"onstage-box in-panel\" };\nconst _hoisted_130 = {\n    key: 0,\n    class: \"onstage-list\"\n};\nconst _hoisted_131 = {\n    key: 0,\n    class: \"empty-tip\"\n};\nconst _hoisted_132 = { class: \"onstage-head\" };\nconst _hoisted_133 = [\"onClick\"];\nconst _hoisted_134 = { class: \"onstage-attrs\" };\nconst _hoisted_135 = { class: \"onstage-thought\" };\nconst _hoisted_136 = { class: \"onstage-box in-panel\" };\nconst _hoisted_137 = {\n    key: 0,\n    class: \"onstage-list\"\n};\nconst _hoisted_138 = {\n    key: 0,\n    class: \"empty-tip\"\n};\nconst _hoisted_139 = { class: \"onstage-head\" };\nconst _hoisted_140 = [\"onClick\"];\nconst _hoisted_141 = { class: \"onstage-attrs\" };\nconst _hoisted_142 = { class: \"onstage-attrs\" };\nconst _hoisted_143 = { class: \"onstage-attrs\" };\nconst _hoisted_144 = { class: \"onstage-thought\" };\nimport _ from 'lodash';\nimport { useDataStore } from './store';\n\nimport { computed, ref, reactive, watch, watchEffect } from 'vue';\nimport { useLocalStorage } from '@vueuse/core';\nconst ability_pick_limit = 2;\nconst skill_points_total = 4;\nconst opening_story = `177828\n\n\n\n\n\n`;\nconst xeno_opening_story = ` / 177828\n\n\n\n\n\n\n\n`;\nexport default /*@__PURE__*/ _defineComponent({\n    __name: 'App',\n    setup(__props) {\n        const store = useDataStore();\n        const data = computed(() => store.data);\n        const is_fullscreen = useLocalStorage('apocalypse_dawn:status_fullscreen', false);\n        const mobile_mode = useLocalStorage('apocalypse_dawn:mobile_mode', false);\n        const status_bar_collapsed = useLocalStorage('apocalypse_dawn:status_collapsed', true);\n        const mvu_font_size = useLocalStorage('apocalypse_dawn:mvu_font_size', 'md');\n        const active_tab = useLocalStorage('apocalypse_dawn:active_tab', 'main');\n        const display_floor_text = computed(() => {\n            const direct = String(data.value... ?? '').trim();\n            if (direct)\n                return direct;\n            return extractFloorTextFromRaw(String(data.value... ?? ''));\n        });\n        const default_next_action_options = [\n            '',\n            '',\n            '',\n            '',\n        ];\n        const next_action_options = ref([...default_next_action_options]);\n        const next_action_panel_mode = useLocalStorage('apocalypse_dawn:next_action_panel_mode', 'options');\n        const manual_action_input = ref('');\n        const is_initial_mvu_focus_mode = computed(() => status_bar_collapsed.value);\n        const onstage_characters = computed(() => {\n            const list = data.value..;\n            return Array.isArray(list) ? list : [];\n        });\n        const module_fold_state = useLocalStorage('apocalypse_dawn:module_fold_state', {\n            : false,\n            NPC: false,\n        });\n        const is_onstage_folded = computed(() => Boolean(data.value..?. ?? module_fold_state.value.));\n        const is_longterm_folded = computed(() => Boolean(data.value..?.NPC ?? module_fold_state.value.NPC));\n        const longterm_npc_list = computed(() => {\n            const source = data.value.?.NPC;\n            if (!source || typeof source !== 'object')\n                return [];\n            return Object.values(source);\n        });\n        const warehouse_items = computed(() => {\n            const source = data.value.?.?.;\n            if (!source || typeof source !== 'object')\n                return [];\n            return Object.entries(source)\n                .map(([name, raw]) => ({\n                name,\n                quality: String(raw?. ?? ''),\n                count: Number(raw?. ?? 0),\n                category: String(raw?. ?? ''),\n                value: Number(raw?. ?? 0),\n                usable: is_library_invitation_item(name) && Number(raw?. ?? 0) > 0,\n            }))\n                .filter(v => v.count > 0)\n                .sort((a, b) => b.count - a.count);\n        });\n        function is_library_invitation_item(name) {\n            const n = String(name ?? '').trim();\n            return ['', ''].includes(n);\n        }\n        function is_default_name(name) {\n            const n = String(name ?? '').trim();\n            return !n || ['', '', '', ''].includes(n);\n        }\n        const create_profile_valid = computed(() => {\n            const build = data.value.?. ?? {};\n            const started = Boolean(build.);\n            if (!started)\n                return false;\n            const profession_ok = build. === '' || build. === '' || build. === '';\n            const name_ok = !is_default_name(String(build. ?? ''));\n            const gender = String(build. ?? '').trim();\n            const gender_ok = build. === '' ? gender === '' : (gender === '' || gender === '');\n            return profession_ok && name_ok && gender_ok;\n        });\n        const show_create = computed(() => !create_profile_valid.value);\n        const has_real_skill_check = computed(() => {\n            const updated = Number(data.value.?.?. ?? 0) > 0;\n            if (!updated)\n                return false;\n            const desc = String(data.value.?.?. ?? '');\n            if (/||/.test(desc))\n                return false;\n            return true;\n        });\n        const create_stage = ref('cover');\n        const create_error = ref('');\n        const cheat_mode = ref(false);\n        const plot_mode = ref(false);\n        const xeno_route_mode = ref(false);\n        const xeno_route_role = ref('');\n        const draft_initialized = ref(false);\n        const warmaid_types = ['', '', '', '', '', ''];\n        const human_keys = ['', '', '', '', '', '', ''];\n        const human_attr_desc = {\n            : { : '', : '' },\n            : { : '', : '' },\n            : { : '', : '' },\n            : { : '', : '' },\n            : { : '', : '' },\n            : { : '', : '' },\n            : { : '', : '' },\n        };\n        const mvu_font_size_options = [\n            { key: 'sm', label: '' },\n            { key: 'md', label: '' },\n            { key: 'lg', label: '' },\n            { key: 'xl', label: '' },\n        ];\n        const air_phase_options = ['', '', '', '', '', '', ''];\n        const air_layer_options = ['', '', '', '', '', ''];\n        const scout_unit_options = ['', '', '', ''];\n        const scout_target_options = ['', '', '', '', ''];\n        const base_ability_map = {\n            : [\n                { name: '', desc: '', source: 'DOCX/' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '/', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX/' },\n            ],\n            : [\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX/' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX/' },\n            ],\n            : [\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n                { name: '', desc: '', source: 'DOCX' },\n            ],\n        };\n        const human_caps = {\n            : 5,\n            : 5,\n            : 5,\n            : 5,\n            : 5,\n            : 5,\n            : 5,\n        };\n        const warmaid_dice_rules = {\n            : { : '4D6', : '2D6', : '2D6', : '2D6', : '6D6', : '1D4' },\n            : { : '4D6', : '3D6', : '3D6', : '3D6', : '5D6', : '2D6' },\n            : { : '4D6', : '4D6', : '3D6', : '5D6', : '4D6', : '3D8' },\n            : { : '4D6', : '6D6', : '5D6', : '6D6', : '3D5', : '4D8' },\n            : { : '4D6', : '10D6', : '7D6', : '10D6', : '1D2', : '7D10' },\n            : { : '4D6', : '5D6', : '4D6', : '10D6', : '1D1', : '4D12' },\n        };\n        const age_limit_map = {\n            : { min: 21, max: 70 },\n            : { min: 12, max: 21 },\n            : { min: 12, max: 80 },\n        };\n        const authority_paths = ['', '', '', '', '', '', '', '', ''];\n        const authority_forbidden_pattern = /||||||||||/i;\n        const background_filter_pattern = /|||||||||/i;\n        const training_keyword_pattern = /|||||||||/;\n        const warmaid_skill_tree = {\n            : [\n                { id: '1', name: '', cost: 1, desc: '1D6', prerequisites: [] },\n                { id: '1.1', name: '', cost: 2, desc: '', prerequisites: ['1'] },\n                { id: '2', name: '', cost: 1, desc: '2D5', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '21D5', prerequisites: ['2'] },\n                { id: '3', name: '', cost: 2, desc: '', prerequisites: [] },\n                { id: '4', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '4.1', name: '', cost: 3, desc: '', prerequisites: ['4'] },\n                { id: '5', name: '', cost: 2, desc: '', prerequisites: [] },\n            ],\n            : [\n                { id: '1', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '1.1', name: '', cost: 2, desc: '', prerequisites: ['1'] },\n                { id: '1.2', name: '', cost: 3, desc: '', prerequisites: ['1', '1.1'] },\n                { id: '2', name: '', cost: 1, desc: '1D6', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '+20', prerequisites: ['2'] },\n                { id: '2.2', name: '', cost: 3, desc: '+10', prerequisites: ['2', '2.1'] },\n                { id: '3', name: '', cost: 1, desc: '/', prerequisites: [] },\n            ],\n            : [\n                { id: '1', name: '', cost: 1, desc: '2', prerequisites: [] },\n                { id: '1.1', name: '', cost: 2, desc: '1D6', prerequisites: ['1'] },\n                { id: '1.2', name: '', cost: 3, desc: '', prerequisites: ['1', '1.1'] },\n                { id: '2', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '//', prerequisites: ['2'] },\n                { id: '2.2', name: '', cost: 3, desc: '', prerequisites: ['2', '2.1'] },\n                { id: '2.3', name: '', cost: 4, desc: '', prerequisites: ['2', '2.1', '2.2'] },\n                { id: '3', name: '', cost: 3, desc: '', prerequisites: [] },\n            ],\n            : [\n                { id: '1', name: '', cost: 1, desc: '1D10', prerequisites: [] },\n                { id: '2', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '', prerequisites: ['2'] },\n                { id: '3', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '3.1', name: '', cost: 2, desc: '', prerequisites: ['3'] },\n                { id: '4', name: '', cost: 3, desc: '', prerequisites: [] },\n            ],\n            : [\n                { id: '1', name: '', cost: 1, desc: '2D10', prerequisites: [] },\n                { id: '1.1', name: '', cost: 2, desc: '40%', prerequisites: ['1'] },\n                { id: '1.2', name: '', cost: 3, desc: '', prerequisites: ['1', '1.1'] },\n                { id: '2', name: '', cost: 2, desc: '1', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '', prerequisites: ['2'] },\n                { id: '2.2', name: '', cost: 3, desc: '', prerequisites: ['2', '2.1'] },\n                { id: '3', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '4', name: '', cost: 6, desc: '', prerequisites: [] },\n            ],\n            : [\n                { id: '1', name: '', cost: 1, desc: '1D10', prerequisites: [] },\n                { id: '2', name: '', cost: 1, desc: '', prerequisites: [] },\n                { id: '2.1', name: '', cost: 2, desc: '', prerequisites: ['2'] },\n                { id: '3', name: '', cost: 1, desc: '', prerequisites: [] },\n            ],\n        };\n        const profession_background_starters = {\n            : `\\n`,\n            : `\\n`,\n            : `\\n`,\n        };\n        const create_form = reactive({\n            : '',\n            : '',\n            : '',\n            : '',\n            : 21,\n        });\n        const selected_warmaid_skills = ref([]);\n        const warmaid_custom_skills = ref('');\n        const background_input = ref('');\n        const background_summary_override = ref('');\n        const authority_build = reactive({\n            : '',\n            : '',\n            : '',\n        });\n        const human_attr = reactive({\n            : 1,\n            : 1,\n            : 1,\n            : 1,\n            : 1,\n            : 1,\n            : 1,\n        });\n        const warmaid_attr = reactive({\n            : 0,\n            : 0,\n            : 0,\n            : 0,\n            : 0,\n            : 0,\n        });\n        const warmaid_rolled = ref(false);\n        const selected_abilities = ref([]);\n        const age_limit = computed(() => age_limit_map[create_form.]);\n        const human_points_left = computed(() => 5 - (_.sum(Object.values(human_attr)) - human_keys.length));\n        const current_base_abilities = computed(() => base_ability_map[create_form.]);\n        const current_ability_title = computed(() => `${create_form.}`);\n        const current_ability_hint = computed(() => {\n            if (create_form. === '')\n                return '';\n            if (create_form. === '')\n                return '';\n            return '';\n        });\n        const current_warmaid_skills = computed(() => warmaid_skill_tree[create_form.] ?? []);\n        const selected_warmaid_skill_cost = computed(() => {\n            const map = new Map(current_warmaid_skills.value.map(v => [v.id, v.cost]));\n            return selected_warmaid_skills.value.reduce((sum, id) => sum + (map.get(id) ?? 0), 0);\n        });\n        const skill_points_left = computed(() => Math.max(0, skill_points_total - selected_warmaid_skill_cost.value));\n        const current_dice_rules = computed(() => {\n            const rule = warmaid_dice_rules[create_form.];\n            return [\n                { key: '', rule: rule. },\n                { key: '', rule: rule. },\n                { key: '', rule: rule. },\n                { key: '', rule: rule. },\n                { key: '', rule: rule. },\n                { key: '', rule: rule. },\n            ];\n        });\n        const warmaid_result_list = computed(() => [\n            { key: '', value: warmaid_attr. },\n            { key: '', value: warmaid_attr. },\n            { key: '', value: warmaid_attr. },\n            { key: '', value: warmaid_attr. },\n            { key: '', value: warmaid_attr. },\n            { key: '', value: warmaid_attr. },\n        ]);\n        const profession = computed(() => {\n            const saved = data.value..?.;\n            if (saved === '' || saved === '' || saved === '')\n                return saved;\n            if (data.value....includes(''))\n                return '';\n            if (data.value....includes(''))\n                return '';\n            return '';\n        });\n        const display_gender = computed(() => {\n            const raw = String(data.value.?.?. ?? '').trim();\n            if (raw)\n                return raw;\n            return profession.value === '' ? '' : '';\n        });\n        const is_warmaid = computed(() => profession.value === '');\n        const human_attributes = computed(() => {\n            const base = data.value..;\n            const train = data.value..;\n            const add_str = is_warmaid.value && data.value... ? data.value... : 0;\n            const add_con = is_warmaid.value && data.value... ? data.value... : 0;\n            return [\n                { key: '', value: base. + add_str, training: train. },\n                { key: '', value: base., training: train. },\n                { key: '', value: base. + add_con, training: train. },\n                { key: '', value: base., training: train. },\n                { key: '', value: base., training: train. },\n                { key: '', value: base., training: train. },\n                { key: '', value: base., training: train. },\n            ];\n        });\n        const warmaid_attributes = computed(() => [\n            { key: '', value: data.value... },\n            { key: '', value: data.value... },\n            { key: '', value: data.value... },\n            { key: '', value: data.value... },\n            { key: '', value: data.value... },\n            { key: '', value: data.value... },\n        ]);\n        const level_label = computed(() => {\n            if (profession.value === '')\n                return '';\n            if (profession.value === '')\n                return '';\n            return '';\n        });\n        const warmaid_rank_names = ['', '', '', '', '', '', ''];\n        const authority_rank_names = ['', '', '', ''];\n        const level_value = computed(() => {\n            if (profession.value === '') {\n                const idx = _.clamp(data.value..., 1, warmaid_rank_names.length) - 1;\n                return warmaid_rank_names[idx];\n            }\n            if (profession.value === '') {\n                const idx = _.clamp(data.value..., 1, authority_rank_names.length) - 1;\n                return authority_rank_names[idx];\n            }\n            return '-';\n        });\n        const level_meta_lines = computed(() => {\n            if (profession.value === '') {\n                const current = _.clamp(data.value..., 1, warmaid_rank_names.length);\n                const next = current < warmaid_rank_names.length ? warmaid_rank_names[current] : '';\n                const need = data.value...;\n                return [\n                    `: ${data.value...}`,\n                    current < warmaid_rank_names.length ? `: ${next} ${need}` : '',\n                ];\n            }\n            if (profession.value === '') {\n                const shard = data.value...;\n                const has_origin = data.value...;\n                const lv = _.clamp(data.value..., 1, authority_rank_names.length);\n                if (lv <= 1)\n                    return [`: ${shard}`, ':  50 '];\n                if (lv === 2)\n                    return [`: ${shard}`, ':  100 '];\n                if (lv === 3)\n                    return [`: ${shard}`, has_origin ? ':  1000 ' : ':  1000  + '];\n                return [`: ${shard}`, `: ${has_origin ? '' : ''}`];\n            }\n            return [''];\n        });\n        function extractFloorTextFromRaw(raw) {\n            if (!raw)\n                return '';\n            const content_match = raw.match(/<content>([\\s\\S]*?)<\\/content>/im);\n            const source = content_match?.[1] ?? raw;\n            return source\n                .replace(/<update(?:variable)?>[\\s\\S]*?<\\/update(?:variable)?>/gim, '')\n                .replace(/<update(?:variable)?>[\\s\\S]*$/gim, '')\n                .replace(/<StatusPlaceHolderImpl\\/>/gim, '')\n                .replace(/<OnStageCharacters>[\\s\\S]*?<\\/OnStageCharacters>/gim, '')\n                .replace(/<NpcRelationHints>[\\s\\S]*?<\\/NpcRelationHints>/gim, '')\n                .replace(/<(?:think|thinking|context|disclaimer|tucao|current_event|progress)[^>]*>[\\s\\S]*?<\\/(?:think|thinking|context|disclaimer|tucao|current_event|progress)>/gim, '')\n                .replace(/<(?:think|thinking|context|disclaimer|tucao|current_event|progress)[^>]*\\/>/gim, '')\n                .replace(/```[\\s\\S]*?```/gim, '')\n                .replace(/<\\/?[^>\\n]+>/g, '')\n                .replace(/\\r/g, '')\n                .replace(/\\n{3,}/g, '\\n\\n')\n                .trim();\n        }\n        function format_attr_text(attrs) {\n            const entries = Object.entries(attrs ?? {});\n            if (entries.length === 0)\n                return '';\n            return `${entries.map(([k, v]) => `${k}:${v}`).join(' / ')}`;\n        }\n        function toggle_module(module_name) {\n            if (!data.value..) {\n                data.value.. = {\n                    : false,\n                    NPC: false,\n                };\n            }\n            const current = Boolean(data.value..[module_name]);\n            data.value..[module_name] = !current;\n            module_fold_state.value = {\n                ...module_fold_state.value,\n                [module_name]: !current,\n            };\n        }\n        function toggle_plot_mode() {\n            plot_mode.value = !plot_mode.value;\n            data.value... = plot_mode.value;\n            if (!data.value..)\n                return;\n            data.value... = plot_mode.value;\n            if (!plot_mode.value) {\n                data.value... = '';\n                data.value... = '';\n            }\n            else if (data.value... === '') {\n                data.value... = '';\n                data.value... =\n                    '';\n            }\n        }\n        function sync_xeno_route_profession() {\n            if (!xeno_route_mode.value)\n                return;\n            if (xeno_route_role.value === '') {\n                create_form. = '';\n                create_form. = '';\n                create_form. = _.clamp(Number(create_form.) || 16, 12, 21);\n                return;\n            }\n            create_form. = '';\n            create_form. = _.clamp(Number(create_form.) || 17, 12, 70);\n        }\n        function start_xeno_route() {\n            xeno_route_mode.value = true;\n            sync_xeno_route_profession();\n            create_stage.value = 'profile';\n        }\n        function start_normal_route() {\n            xeno_route_mode.value = false;\n            create_stage.value = 'profile';\n        }\n        watch(() => create_form., () => {\n            create_form. = _.clamp(Number(create_form.) || age_limit.value.min, age_limit.value.min, age_limit.value.max);\n            if (create_form. === '')\n                create_form. = '';\n            const valid_ability_names = new Set(current_base_abilities.value.map(v => v.name));\n            selected_abilities.value = selected_abilities.value.filter(name => valid_ability_names.has(name));\n            selected_warmaid_skills.value = [];\n            warmaid_custom_skills.value = '';\n            authority_build. = '';\n            authority_build. = '';\n            authority_build. = '';\n            if (create_form. !== '') {\n                warmaid_rolled.value = false;\n                Object.assign(warmaid_attr, { : 0, : 0, : 0, : 0, : 0, : 0 });\n            }\n        }, { immediate: true });\n        watch(() => xeno_route_role.value, () => {\n            sync_xeno_route_profession();\n        });\n        watch(() => create_form., () => {\n            warmaid_rolled.value = false;\n        });\n        watch(() => show_create.value, show => {\n            if (!show) {\n                draft_initialized.value = false;\n                return;\n            }\n            if (draft_initialized.value)\n                return;\n            const saved = data.value..;\n            if (!saved)\n                return;\n            if (saved. && create_profile_valid.value)\n                return;\n            create_form. = saved. || '';\n            create_form. = saved.;\n            create_form. = saved.;\n            create_form. = saved. === '' ? '' : create_form. === '' ? '' : '';\n            create_form. = saved.;\n            cheat_mode.value = Boolean(saved.);\n            plot_mode.value = Boolean(saved.);\n            xeno_route_mode.value = Boolean(saved.);\n            xeno_route_role.value = String(saved.) === '' ? '' : '';\n            sync_xeno_route_profession();\n            draft_initialized.value = true;\n        }, { immediate: true });\n        watchEffect(() => {\n            if (show_create.value)\n                return;\n            const in_air_battle = data.value... === '' && data.value...;\n            if (in_air_battle)\n                active_tab.value = 'battle';\n        });\n        function build_next_actions_from_reply(text) {\n            const t = text.trim();\n            if (!t)\n                return [...default_next_action_options];\n            const bad_action_pattern = /^(|||||||||||||||)/;\n            const action_noise_pattern = /(|||||||||||AI|)/;\n            const normalize_action = (raw) => {\n                return String(raw ?? '')\n                    .replace(/^[:\\-\\s]+/, '')\n                    .replace(/[:\\-\\s]+$/, '')\n                    .replace(/[!?.]+$/g, '')\n                    .trim();\n            };\n            const is_valid_action = (action) => {\n                if (!action)\n                    return false;\n                if (action.length < 6 || action.length > 24)\n                    return false;\n                if (bad_action_pattern.test(action))\n                    return false;\n                if (action_noise_pattern.test(action))\n                    return false;\n                if (!/^(||||||||||||||||||||||||||)/.test(action))\n                    return false;\n                return true;\n            };\n            const pool = [];\n            const pushUnique = (v) => {\n                const s = normalize_action(v);\n                if (!is_valid_action(s))\n                    return;\n                if (!pool.includes(s))\n                    pool.push(s);\n            };\n            const direct_candidates = Array.from(new Set(t\n                .split(/\\n|||!||\\?/)\n                .map(v => v.trim())\n                .filter(Boolean)\n                .flatMap((line) => {\n                const out = [];\n                const m1 = line.match(/(?:||||||)([^\\n]{3,24})/);\n                if (m1?.[1])\n                    out.push(m1[1]);\n                const m2 = line.match(/(?:|||||||||||)[^\\n]{2,24}/);\n                if (m2?.[0])\n                    out.push(m2[0]);\n                return out;\n            })\n                .map(normalize_action)));\n            for (const candidate of direct_candidates)\n                pushUnique(candidate);\n            if (/||||/.test(t)) {\n                pushUnique('');\n                pushUnique('');\n            }\n            if (/|||||/.test(t)) {\n                pushUnique('');\n                pushUnique('');\n                pushUnique('');\n            }\n            if (/||||/.test(t)) {\n                pushUnique('');\n                pushUnique('');\n            }\n            if (/|||/.test(t)) {\n                pushUnique('');\n                pushUnique('');\n            }\n            if (/|||/.test(t)) {\n                pushUnique('');\n            }\n            if (/|||/.test(t)) {\n                pushUnique('');\n            }\n            const current_stage = String(data.value.?.?. ?? '');\n            if (current_stage === '') {\n                pushUnique('');\n                pushUnique('');\n            }\n            else if (current_stage === '') {\n                pushUnique('');\n                pushUnique('');\n            }\n            else if (current_stage === '') {\n                pushUnique('');\n                pushUnique('');\n            }\n            const first_npc = String(onstage_characters.value?.[0]?. ?? '').trim();\n            if (first_npc) {\n                pushUnique(`${first_npc}`);\n            }\n            // fallback\n            pushUnique('');\n            pushUnique('');\n            pushUnique('');\n            pushUnique('');\n            return ensure_four_actions(pool.slice(0, 4));\n        }\n        function ensure_four_actions(list) {\n            const result = [];\n            for (const item of list) {\n                const t = String(item ?? '').trim();\n                if (!t)\n                    continue;\n                if (!result.includes(t))\n                    result.push(t);\n                if (result.length >= 4)\n                    return result;\n            }\n            for (const item of default_next_action_options) {\n                if (!result.includes(item))\n                    result.push(item);\n                if (result.length >= 4)\n                    break;\n            }\n            return result.slice(0, 4);\n        }\n        watch(() => display_floor_text.value, (val) => {\n            const source = String(val ?? '').trim() || String(data.value.?.?. ?? '');\n            next_action_options.value = ensure_four_actions(build_next_actions_from_reply(source));\n        }, { immediate: true });\n        watch(() => Number(data.value.?.?. ?? 0), () => {\n            const source = String(display_floor_text.value ?? '').trim() || String(data.value.?.?. ?? '');\n            next_action_options.value = ensure_four_actions(build_next_actions_from_reply(source));\n        });\n        watch(() => String(data.value.?.?. ?? ''), (raw) => {\n            if (!raw)\n                return;\n            const source = String(display_floor_text.value ?? '').trim() || raw;\n            next_action_options.value = ensure_four_actions(build_next_actions_from_reply(source));\n        });\n        function change_human(key, delta) {\n            if (delta > 0) {\n                if (human_points_left.value <= 0)\n                    return;\n                if (human_attr[key] >= human_caps[key])\n                    return;\n                human_attr[key] += 1;\n                return;\n            }\n            if (human_attr[key] <= 1)\n                return;\n            human_attr[key] -= 1;\n        }\n        function go_human_step() {\n            create_error.value = '';\n            const name = create_form..trim();\n            if (!name) {\n                create_error.value = '';\n                return;\n            }\n            const limit = age_limit.value;\n            const age = Number(create_form.);\n            if (!cheat_mode.value && (!Number.isFinite(age) || age < limit.min || age > limit.max)) {\n                create_error.value = `${limit.min}-${limit.max}`;\n                return;\n            }\n            create_stage.value = 'human';\n        }\n        function go_next_after_human() {\n            create_error.value = '';\n            if (!cheat_mode.value && human_points_left.value !== 0) {\n                create_error.value = ' 5 ';\n                return;\n            }\n            create_stage.value = 'abilities';\n        }\n        function toggle_ability(name) {\n            create_error.value = '';\n            const current = selected_abilities.value;\n            if (current.includes(name)) {\n                selected_abilities.value = current.filter(v => v !== name);\n                return;\n            }\n            if (current.length >= ability_pick_limit) {\n                create_error.value = ` ${ability_pick_limit} `;\n                return;\n            }\n            selected_abilities.value = [...current, name];\n        }\n        function go_next_after_abilities() {\n            create_error.value = '';\n            if (!cheat_mode.value && selected_abilities.value.length === 0) {\n                create_error.value = ' 1 ';\n                return;\n            }\n            create_stage.value = 'profession';\n        }\n        function hasWarmaidSkillPrerequisites(skill_id) {\n            const node = current_warmaid_skills.value.find(v => v.id === skill_id);\n            if (!node)\n                return false;\n            return node.prerequisites.every(pre => selected_warmaid_skills.value.includes(pre));\n        }\n        function toggle_warmaid_skill(skill_id) {\n            create_error.value = '';\n            const node = current_warmaid_skills.value.find(v => v.id === skill_id);\n            if (!node)\n                return;\n            if (selected_warmaid_skills.value.includes(skill_id)) {\n                const used_as_pre = current_warmaid_skills.value.some(v => selected_warmaid_skills.value.includes(v.id) && v.prerequisites.includes(skill_id));\n                if (used_as_pre && !cheat_mode.value) {\n                    create_error.value = '';\n                    return;\n                }\n                selected_warmaid_skills.value = selected_warmaid_skills.value.filter(v => v !== skill_id);\n                return;\n            }\n            if (!cheat_mode.value && !hasWarmaidSkillPrerequisites(skill_id)) {\n                create_error.value = ` ${skill_id} `;\n                return;\n            }\n            if (!cheat_mode.value && selected_warmaid_skill_cost.value + node.cost > skill_points_total) {\n                create_error.value = ` ${skill_points_total} `;\n                return;\n            }\n            selected_warmaid_skills.value = [...selected_warmaid_skills.value, skill_id];\n        }\n        function sanitizeBackground(raw) {\n            const compact = raw\n                .split(/\\r?\\n/)\n                .map(line => line.trim())\n                .filter(Boolean)\n                .filter(line => !background_filter_pattern.test(line))\n                .join(' ');\n            return compact.slice(0, 320);\n        }\n        function validateAuthorityBuild() {\n            if (create_form. !== '')\n                return '';\n            if (!authority_build..trim())\n                return '';\n            if (!authority_build..trim())\n                return '';\n            const merged = `${authority_build.}\\n${authority_build.}`;\n            if (!cheat_mode.value && authority_forbidden_pattern.test(merged)) {\n                return '//';\n            }\n            return '';\n        }\n        function go_next_after_profession() {\n            create_error.value = '';\n            if (create_form. === '' && !cheat_mode.value && selected_warmaid_skills.value.length === 0) {\n                create_error.value = '1';\n                return;\n            }\n            const authority_err = validateAuthorityBuild();\n            if (authority_err) {\n                create_error.value = authority_err;\n                return;\n            }\n            create_stage.value = 'background';\n        }\n        function go_next_after_background() {\n            create_error.value = '';\n            if (!background_input.value.trim() && !cheat_mode.value) {\n                create_error.value = '';\n                return;\n            }\n            if (create_form. === '') {\n                create_stage.value = 'warmaid';\n                return;\n            }\n            finish_create();\n        }\n        function rollD(sides) {\n            return Math.floor(Math.random() * sides) + 1;\n        }\n        function ensure_air_defaults() {\n            if (!data.value.?.?.)\n                return;\n            if (!data.value...)\n                data.value... = {};\n        }\n        function roll_air_weather() {\n            ensure_air_defaults();\n            const r = rollD(100);\n            const air = data.value...;\n            air. = r;\n            air. = [];\n            if (r <= 10) {\n                air. = '';\n                air. = 10;\n                air. = 50;\n                air. = 1;\n            }\n            else if (r <= 70) {\n                air. = '';\n                air. = 5;\n                air. = 0;\n                air. = 1;\n            }\n            else if (r <= 80) {\n                air. = '';\n                air. = -10;\n                air. = -50;\n                air. = 0.5;\n            }\n            else if (r <= 90) {\n                air. = '';\n                air. = -15;\n                air. = -50;\n                air. = 0.5;\n            }\n            else {\n                air. = '';\n                air. = -20;\n                air. = -30;\n                air. = 0.6;\n                air. = ['E3', 'H6'];\n            }\n            data.value.[`-${Date.now()}`] = `${air.}d100=${r}${air.}`;\n        }\n        function score_air_side(side) {\n            return side. * 3 + side. * 3 + side. * 2 + side. + side.;\n        }\n        function calc_air_superiority() {\n            ensure_air_defaults();\n            const air = data.value...;\n            const my_recon = air..;\n            const enemy_recon = air..;\n            air. = score_air_side(air.);\n            air. = score_air_side(air.);\n            if (!air. && my_recon > 0 && enemy_recon === 0) {\n                data.value... = '';\n                air. = 1;\n                air. = '';\n            }\n            else if (!air. && enemy_recon > 0 && my_recon === 0) {\n                data.value... = '';\n                air. = -1;\n                air. = '/';\n            }\n            else if (air. > air.) {\n                data.value... = '';\n                air. = 1;\n                air. = '';\n            }\n            else if (air. < air.) {\n                data.value... = '';\n                air. = -1;\n                air. = '/';\n            }\n            else {\n                data.value... = '';\n                air. = 0;\n                air. = '';\n            }\n            data.value.[`-${Date.now()}`] = `${air.}/${air.}${data.value...}`;\n        }\n        function run_air_recon() {\n            ensure_air_defaults();\n            const air = data.value...;\n            const base_roll = rollD(10);\n            let bonus = 0;\n            if (air. === '')\n                bonus = rollD(10);\n            else if (air. === '')\n                bonus = rollD(5);\n            else if (air. === '')\n                bonus = rollD(20);\n            else\n                bonus = 10;\n            const hide_map = { : 10, : 8, : 5, : 2, : 1 };\n            const target = air.;\n            const origin_hide = hide_map[target];\n            const roll = base_roll + bonus + air.;\n            const tag_text = Object.entries(data.value...)\n                .map(([k, v]) => `${k}:${v.join(',')}`)\n                .join(' | ');\n            const has_camo = //.test(tag_text);\n            const has_huge = /||/.test(tag_text);\n            let remaining = has_huge ? 0 : origin_hide;\n            if (!has_huge) {\n                if (!has_camo)\n                    remaining = Math.max(0, origin_hide - roll);\n            }\n            air. = roll;\n            air. = remaining;\n            data.value.[`-${Date.now()}`] = `${air.}${target}${roll}${remaining}${has_camo ? '' : ''}`;\n        }\n        function record_air_tag(side) {\n            ensure_air_defaults();\n            const unit = window.prompt(`${side}`)?.trim();\n            const tags = window.prompt(',')?.trim();\n            if (!unit || !tags)\n                return;\n            const list = tags.split(',').map(v => v.trim()).filter(Boolean);\n            data.value...[`${side}-${unit}`] = list;\n            data.value.[`-${Date.now()}`] = `${side}-${unit} => ${list.join(',')}`;\n        }\n        function finish_air_battle_and_feedback() {\n            ensure_air_defaults();\n            const air = data.value...;\n            const logs = Object.entries(data.value.).slice(-3).map(([k, v]) => `${k}:${v}`).join('');\n            const tag_lines = Object.entries(data.value...).map(([k, v]) => `${k}[${v.join(',')}]`).join('') || '';\n            const summary = `=${air.}(${air.})=${air.}=${data.value...}${air. >= 0 ? '+' : ''}${air.}=${air. ? `/${air.}` : ''}=${air.}/=${air.}=${tag_lines}=${logs}`;\n            data.value.. = {\n                : true,\n                : summary,\n                : Date.now(),\n            };\n            data.value... = false;\n            data.value... = '';\n            data.value.... = '';\n            data.value... = summary;\n            data.value.[`-${Date.now()}`] = summary;\n        }\n        function rollExpr(expr) {\n            const m = expr.trim().toUpperCase().match(/^(\\d+)D(\\d+)$/);\n            if (!m)\n                return 0;\n            const count = Number(m[1]);\n            const sides = Number(m[2]);\n            let total = 0;\n            for (let i = 0; i < count; i += 1)\n                total += rollD(sides);\n            return total;\n        }\n        function roll_warmaid_stats() {\n            create_error.value = '';\n            const rule = warmaid_dice_rules[create_form.];\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_attr. = rollExpr(rule.);\n            warmaid_rolled.value = true;\n        }\n        function finish_create() {\n            create_error.value = '';\n            if (create_form. === '' && !warmaid_rolled.value && !cheat_mode.value) {\n                create_error.value = '';\n                return;\n            }\n            const name = create_form..trim();\n            if (!name) {\n                create_error.value = '';\n                return;\n            }\n            const authority_err = validateAuthorityBuild();\n            if (authority_err) {\n                create_error.value = authority_err;\n                return;\n            }\n            const bg_raw = background_input.value.trim();\n            const bg_summary = background_summary_override.value.trim() || sanitizeBackground(bg_raw);\n            const training_source = `${bg_raw}\\n${bg_summary}`;\n            const training_state = training_keyword_pattern.test(training_source) ? '' : '';\n            data.value.. = {\n                : true,\n                : name,\n                : create_form.,\n                : create_form.,\n                : create_form. === '' ? '' : create_form.,\n                : Number(create_form.),\n                : cheat_mode.value,\n                : plot_mode.value,\n            };\n            data.value... = name;\n            _.set(data.value, '..', create_form. === '' ? '' : create_form.);\n            if (xeno_route_mode.value) {\n                data.value... = '';\n                data.value... = xeno_route_role.value === '' ? '' : '';\n                data.value... =\n                    xeno_route_role.value === '' ? `--${create_form.}` : '-';\n            }\n            else {\n                data.value... = create_form. === '' ? `-${create_form.}` : create_form.;\n            }\n            data.value.. = { ...human_attr };\n            data.value.. = {\n                : 0,\n                : 0,\n                : 0,\n                : 0,\n                : 0,\n                : 0,\n                : 0,\n            };\n            // \n            const max_hp = Math.max(100, Number(human_attr. || 1) * 100);\n            data.value... = max_hp;\n            data.value... = max_hp;\n            data.value... = 0;\n            data.value... = 1;\n            data.value... = 1;\n            data.value... = 10;\n            data.value... = 10;\n            if (create_form. === '') {\n                data.value.. = { ...warmaid_attr };\n                const max_mp = Math.max(20, warmaid_attr. * 10);\n                data.value... = max_mp;\n                data.value... = max_mp;\n                data.value... = Math.max(1, Math.ceil(max_mp / 10));\n            }\n            else {\n                data.value.. = {\n                    : 0,\n                    : 0,\n                    : 0,\n                    : 0,\n                    : 0,\n                    : 0,\n                };\n                data.value... = 100;\n                data.value... = 100;\n            }\n            data.value... = false;\n            data.value... = false;\n            data.value... = data.value...;\n            data.value... = [...selected_abilities.value];\n            data.value.. = {\n                : skill_points_total - selected_warmaid_skill_cost.value,\n                : selected_warmaid_skill_cost.value,\n                : Object.fromEntries(selected_warmaid_skills.value.map(id => [id, true])),\n                : warmaid_custom_skills.value.trim(),\n            };\n            data.value.. = {\n                : authority_build..trim(),\n                : authority_build.,\n                : create_form. === '' ? 1 : 0,\n                : authority_build..trim(),\n                : create_form. !== '' ? false : !authority_forbidden_pattern.test(`${authority_build.}\\n${authority_build.}`),\n                : create_form. === '' ? '' : '',\n            };\n            data.value.. = {\n                : bg_raw,\n                : bg_summary,\n            };\n            data.value... = 1;\n            data.value... = 1;\n            data.value... = 0;\n            data.value... = 10;\n            data.value... = 0;\n            data.value... = false;\n            data.value.. = '177828 08:00';\n            data.value.. = '  ';\n            data.value.. = '';\n            data.value.. = {\n                : plot_mode.value,\n                : training_state,\n                : plot_mode.value ? '' : '',\n                : 0,\n                : 0,\n                : false,\n                : false,\n                : false,\n                : plot_mode.value\n                    ? ''\n                    : '',\n            };\n            data.value.. = {\n                : '',\n                : '',\n                : '',\n                : bg_summary || '',\n                : training_state === '' ? '/' : '//',\n                : plot_mode.value\n                    ? '1/3 '\n                    : '',\n                ...(xeno_route_mode.value\n                    ? {\n                        : `${xeno_route_role.value}`,\n                        : '',\n                    }\n                    : {}),\n            };\n            data.value. = {\n                : xeno_route_mode.value\n                    ? `177828${xeno_route_role.value}`\n                    : '177828',\n            };\n            data.value.. = {\n                : xeno_route_mode.value ? xeno_opening_story : opening_story,\n                : xeno_route_mode.value ? xeno_opening_story : opening_story,\n                : Date.now(),\n            };\n            data.value.. = [];\n            data.value.. = {\n                : false,\n                NPC: false,\n            };\n            module_fold_state.value = {\n                : false,\n                NPC: false,\n            };\n            data.value.. = false;\n            data.value.. = {};\n            data.value.. = {};\n            data.value.. = {\n                : false,\n                : '',\n                : '',\n                : '',\n                : 0,\n                : 0,\n                : 0,\n                : '',\n                : '',\n                : [],\n            };\n            data.value.. = {\n                : 0,\n                : 0,\n                : {},\n                : [],\n            };\n            data.value.. = {\n                : false,\n                : '',\n                : 0,\n            };\n            data.value.. = {\n                : false,\n                : '',\n                : 0,\n            };\n            data.value..NPC = {};\n            data.value..NPC = {};\n            data.value... = {};\n            data.value... = {\n                : false,\n                : '',\n                : '',\n                : 11,\n                : 5,\n                : 0,\n                : 1,\n                : '',\n                : 500,\n                : { : 0, : 0, : 0, : 0, : 0, : 0 },\n                : { : 0, : 0, : 0, : 0, : 0, : 0 },\n                : 0,\n                : 0,\n                : 0,\n                : '',\n                : false,\n                : '',\n                : [],\n                : [],\n                : '',\n                : '',\n                : 0,\n                : 0,\n                : 3,\n                : 3,\n                : 0,\n                : 0,\n                : '',\n                : 100,\n                : 100,\n                : 0,\n                : '',\n            };\n        }\n        function toggle_transform() {\n            if (!is_warmaid.value)\n                return;\n            const next = !data.value...;\n            data.value... = next;\n            data.value... = next;\n            if (next) {\n                data.value... = data.value...;\n            }\n        }\n        async function dispatch_action_to_tavern(action) {\n            // /DOM\n            try {\n                if (typeof createChatMessages === 'function') {\n                    await createChatMessages([{ role: 'user', message: action }]);\n                    if (typeof triggerSlash === 'function')\n                        triggerSlash('/trigger');\n                    return;\n                }\n            }\n            catch (error) {\n                console.warn('[] createChatMessages ', error);\n            }\n            //  iframe  DOM postMessage \n            try {\n                const payload = {\n                    type: 'apocalypse-dawn:send_action',\n                    source: 'apocalypse_dawn_mvu',\n                    action,\n                    ts: Date.now(),\n                };\n                if (window.parent)\n                    window.parent.postMessage(payload, '*');\n                if (window.top && window.top !== window.parent)\n                    window.top.postMessage(payload, '*');\n            }\n            catch { }\n            const docs = [];\n            docs.push(window.document);\n            try {\n                if (window.parent?.document && window.parent.document !== window.document)\n                    docs.push(window.parent.document);\n            }\n            catch { }\n            try {\n                if (window.top?.document && window.top.document !== window.document)\n                    docs.push(window.top.document);\n            }\n            catch { }\n            const textarea_selectors = ['#send_textarea', 'textarea#send_textarea', 'textarea[id*=\\\"send\\\"]', 'textarea'];\n            const send_btn_selectors = ['#send_but', 'button#send_but', '#send-button', 'button[type=\\\"submit\\\"]'];\n            for (const doc of docs) {\n                let input_el = null;\n                for (const sel of textarea_selectors) {\n                    const el = doc.querySelector(sel);\n                    if (el instanceof HTMLTextAreaElement) {\n                        input_el = el;\n                        break;\n                    }\n                }\n                if (!input_el)\n                    continue;\n                input_el.value = action;\n                input_el.dispatchEvent(new Event('input', { bubbles: true }));\n                input_el.dispatchEvent(new Event('change', { bubbles: true }));\n                for (const sel of send_btn_selectors) {\n                    const btn = doc.querySelector(sel);\n                    if (btn instanceof HTMLElement) {\n                        btn.click();\n                        return;\n                    }\n                }\n            }\n            //  message \n            console.info('[]  postMessage ');\n        }\n        async function send_next_action(action) {\n            const ok = window.confirm(`\\n${action}`);\n            if (!ok)\n                return;\n            await dispatch_action_to_tavern(action);\n        }\n        function toggle_next_action_panel_mode() {\n            next_action_panel_mode.value = next_action_panel_mode.value === 'options' ? 'input' : 'options';\n        }\n        function clear_manual_action() {\n            manual_action_input.value = '';\n        }\n        async function send_manual_action() {\n            const action = manual_action_input.value.trim();\n            if (!action)\n                return;\n            await dispatch_action_to_tavern(action);\n            manual_action_input.value = '';\n        }\n        async function use_warehouse_item(item_name) {\n            if (!is_library_invitation_item(item_name))\n                return;\n            const stock = _.get(data.value, ['', '', '', item_name, ''], 0);\n            if (Number(stock) <= 0)\n                return;\n            const ok = window.confirm(`${item_name}\\n1`);\n            if (!ok)\n                return;\n            _.set(data.value, ['', '', '', item_name, ''], Math.max(0, Number(stock) - 1));\n            _.set(data.value, ['', '', ''], '');\n            const action = '/';\n            await send_next_action(action);\n        }\n        function toggle_mobile_mode() {\n            mobile_mode.value = !mobile_mode.value;\n        }\n        function toggle_status_bar() {\n            status_bar_collapsed.value = !status_bar_collapsed.value;\n        }\n        function delete_onstage_npc(raw_name) {\n            const name = String(raw_name ?? '').trim();\n            if (!name)\n                return;\n            if (!window.confirm(`${name}`))\n                return;\n            const list = Array.isArray(data.value.?.) ? data.value.. : [];\n            data.value.. = list.filter((v) => String(v?. ?? '').trim() !== name);\n        }\n        function delete_longterm_npc(raw_name) {\n            const name = String(raw_name ?? '').trim();\n            if (!name)\n                return;\n            if (!window.confirm(`NPC${name}\\n`))\n                return;\n            _.unset(data.value, ['', 'NPC', name]);\n            _.unset(data.value, ['', 'NPC', name]);\n            const onstage = Array.isArray(data.value.?.) ? data.value.. : [];\n            data.value.. = onstage.filter((v) => String(v?. ?? '').trim() !== name);\n        }\n        const profession_background_starter = computed(() => profession_background_starters[create_form.]);\n        function apply_background_starter(append) {\n            const starter = profession_background_starter.value.trim();\n            if (!starter)\n                return;\n            if (!append || !background_input.value.trim()) {\n                background_input.value = starter;\n                return;\n            }\n            background_input.value = `${background_input.value.trim()}\\n\\n${starter}`;\n        }\n        return (_ctx, _cache) => {\n            return (_openBlock(), _createElementBlock(\"div\", {\n                class: _normalizeClass([\"card\", { fullscreen: _unref(is_fullscreen), 'mobile-mode': _unref(mobile_mode) }])\n            }, [\n                (_unref(show_create))\n                    ? (_openBlock(), _createElementBlock(\"section\", _hoisted_1, [\n                        (_unref(create_stage) === 'cover')\n                            ? (_openBlock(), _createElementBlock(\"section\", _hoisted_2, [\n                                _cache[29] || (_cache[29] = _createElementVNode(\"h1\", { class: \"logo\" }, \"\", -1 /* CACHED */)),\n                                _cache[30] || (_cache[30] = _createElementVNode(\"p\", { class: \"author\" }, \"\", -1 /* CACHED */)),\n                                _createElementVNode(\"div\", _hoisted_3, [\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: \"start-btn large\",\n                                        onClick: start_normal_route\n                                    }, \"\"),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"xeno-btn large\", { active: _unref(xeno_route_mode) }]),\n                                        onClick: start_xeno_route\n                                    }, _toDisplayString(_unref(xeno_route_mode) ? '' : ''), 3 /* TEXT, CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"plot-btn large\", { active: _unref(plot_mode) }]),\n                                        onClick: toggle_plot_mode\n                                    }, _toDisplayString(_unref(plot_mode) ? '' : ''), 3 /* TEXT, CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"mobile-btn large\", { active: _unref(mobile_mode) }]),\n                                        onClick: toggle_mobile_mode\n                                    }, _toDisplayString(_unref(mobile_mode) ? '' : ''), 3 /* TEXT, CLASS */)\n                                ]),\n                                _createElementVNode(\"button\", {\n                                    type: \"button\",\n                                    class: _normalizeClass([\"cheat-btn\", { active: _unref(cheat_mode) }]),\n                                    onClick: _cache[0] || (_cache[0] = ($event) => (cheat_mode.value = !_unref(cheat_mode)))\n                                }, _toDisplayString(_unref(cheat_mode) ? '' : ''), 3 /* TEXT, CLASS */)\n                            ]))\n                            : (_unref(create_stage) === 'profile')\n                                ? (_openBlock(), _createElementBlock(\"section\", _hoisted_4, [\n                                    _cache[42] || (_cache[42] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                    (_unref(xeno_route_mode))\n                                        ? (_openBlock(), _createElementBlock(\"div\", _hoisted_5, [\n                                            _cache[33] || (_cache[33] = _createElementVNode(\"p\", { class: \"tip strong\" }, \"\", -1 /* CACHED */)),\n                                            _createElementVNode(\"label\", _hoisted_6, [\n                                                _cache[32] || (_cache[32] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                _withDirectives(_createElementVNode(\"select\", {\n                                                    \"onUpdate:modelValue\": _cache[1] || (_cache[1] = ($event) => (_isRef(xeno_route_role) ? (xeno_route_role).value = $event : null))\n                                                }, [...(_cache[31] || (_cache[31] = [\n                                                        _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */),\n                                                        _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */)\n                                                    ]))], 512 /* NEED_PATCH */), [\n                                                    [_vModelSelect, _unref(xeno_route_role)]\n                                                ])\n                                            ]),\n                                            _cache[34] || (_cache[34] = _createElementVNode(\"p\", { class: \"tip\" }, \"\", -1 /* CACHED */))\n                                        ]))\n                                        : _createCommentVNode(\"v-if\", true),\n                                    _createElementVNode(\"label\", _hoisted_7, [\n                                        _cache[35] || (_cache[35] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                        _withDirectives(_createElementVNode(\"input\", {\n                                            \"onUpdate:modelValue\": _cache[2] || (_cache[2] = ($event) => ((_unref(create_form).) = $event)),\n                                            type: \"text\",\n                                            placeholder: \"\"\n                                        }, null, 512 /* NEED_PATCH */), [\n                                            [\n                                                _vModelText,\n                                                _unref(create_form).,\n                                                void 0,\n                                                { trim: true }\n                                            ]\n                                        ])\n                                    ]),\n                                    (!_unref(xeno_route_mode))\n                                        ? (_openBlock(), _createElementBlock(\"label\", _hoisted_8, [\n                                            _cache[37] || (_cache[37] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                            _withDirectives(_createElementVNode(\"select\", {\n                                                \"onUpdate:modelValue\": _cache[3] || (_cache[3] = ($event) => ((_unref(create_form).) = $event))\n                                            }, [...(_cache[36] || (_cache[36] = [\n                                                    _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */),\n                                                    _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */),\n                                                    _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */)\n                                                ]))], 512 /* NEED_PATCH */), [\n                                                [_vModelSelect, _unref(create_form).]\n                                            ])\n                                        ]))\n                                        : (_openBlock(), _createElementBlock(\"p\", _hoisted_9, \"\" + _toDisplayString(_unref(create_form).) + \"\" + _toDisplayString(_unref(xeno_route_role)) + \"\", 1 /* TEXT */)),\n                                    (_unref(create_form). === '')\n                                        ? (_openBlock(), _createElementBlock(\"label\", _hoisted_10, [\n                                            _cache[38] || (_cache[38] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                            _withDirectives(_createElementVNode(\"select\", {\n                                                \"onUpdate:modelValue\": _cache[4] || (_cache[4] = ($event) => ((_unref(create_form).) = $event))\n                                            }, [\n                                                (_openBlock(), _createElementBlock(_Fragment, null, _renderList(warmaid_types, (kind) => {\n                                                    return _createElementVNode(\"option\", {\n                                                        key: kind,\n                                                        value: kind\n                                                    }, _toDisplayString(kind), 9 /* TEXT, PROPS */, _hoisted_11);\n                                                }), 64 /* STABLE_FRAGMENT */))\n                                            ], 512 /* NEED_PATCH */), [\n                                                [_vModelSelect, _unref(create_form).]\n                                            ])\n                                        ]))\n                                        : _createCommentVNode(\"v-if\", true),\n                                    _createElementVNode(\"label\", _hoisted_12, [\n                                        _cache[39] || (_cache[39] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                        _withDirectives(_createElementVNode(\"input\", {\n                                            \"onUpdate:modelValue\": _cache[5] || (_cache[5] = ($event) => ((_unref(create_form).) = $event)),\n                                            type: \"number\",\n                                            min: _unref(age_limit).min,\n                                            max: _unref(age_limit).max\n                                        }, null, 8 /* PROPS */, _hoisted_13), [\n                                            [\n                                                _vModelText,\n                                                _unref(create_form).,\n                                                void 0,\n                                                { number: true }\n                                            ]\n                                        ])\n                                    ]),\n                                    _createElementVNode(\"label\", _hoisted_14, [\n                                        _cache[41] || (_cache[41] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                        _withDirectives(_createElementVNode(\"select\", {\n                                            \"onUpdate:modelValue\": _cache[6] || (_cache[6] = ($event) => ((_unref(create_form).) = $event)),\n                                            disabled: _unref(create_form). === ''\n                                        }, [...(_cache[40] || (_cache[40] = [\n                                                _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */),\n                                                _createElementVNode(\"option\", { value: \"\" }, \"\", -1 /* CACHED */)\n                                            ]))], 8 /* PROPS */, _hoisted_15), [\n                                            [_vModelSelect, _unref(create_form).]\n                                        ])\n                                    ]),\n                                    (_unref(create_form). === '')\n                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_16, \"\"))\n                                        : _createCommentVNode(\"v-if\", true),\n                                    _createElementVNode(\"p\", _hoisted_17, \"\" + _toDisplayString(_unref(age_limit).min) + \" - \" + _toDisplayString(_unref(age_limit).max), 1 /* TEXT */),\n                                    (_unref(create_error))\n                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_18, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                        : _createCommentVNode(\"v-if\", true),\n                                    _createElementVNode(\"div\", _hoisted_19, [\n                                        _createElementVNode(\"button\", {\n                                            type: \"button\",\n                                            class: \"secondary-btn\",\n                                            onClick: _cache[7] || (_cache[7] = ($event) => (create_stage.value = 'cover'))\n                                        }, \"\"),\n                                        _createElementVNode(\"button\", {\n                                            type: \"button\",\n                                            class: \"start-btn\",\n                                            onClick: go_human_step\n                                        }, \"\")\n                                    ])\n                                ]))\n                                : (_unref(create_stage) === 'human')\n                                    ? (_openBlock(), _createElementBlock(\"section\", _hoisted_20, [\n                                        _cache[44] || (_cache[44] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                        _cache[45] || (_cache[45] = _createElementVNode(\"p\", { class: \"tip\" }, \" 1 5  5\", -1 /* CACHED */)),\n                                        _createElementVNode(\"p\", _hoisted_21, \"\" + _toDisplayString(_unref(human_points_left)), 1 /* TEXT */),\n                                        _createElementVNode(\"ul\", _hoisted_22, [\n                                            (_openBlock(), _createElementBlock(_Fragment, null, _renderList(human_keys, (key) => {\n                                                return _createElementVNode(\"li\", { key: key }, [\n                                                    _createElementVNode(\"div\", _hoisted_23, [\n                                                        _createElementVNode(\"span\", null, _toDisplayString(key) + \" \" + _toDisplayString(human_caps[key]) + \"\", 1 /* TEXT */),\n                                                        _createElementVNode(\"small\", _hoisted_24, _toDisplayString(human_attr_desc[key].), 1 /* TEXT */)\n                                                    ]),\n                                                    _createElementVNode(\"div\", _hoisted_25, [\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            onClick: ($event) => (change_human(key, -1))\n                                                        }, \"-\", 8 /* PROPS */, _hoisted_26),\n                                                        _createElementVNode(\"strong\", null, _toDisplayString(_unref(human_attr)[key]), 1 /* TEXT */),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            onClick: ($event) => (change_human(key, 1))\n                                                        }, \"+\", 8 /* PROPS */, _hoisted_27)\n                                                    ])\n                                                ]);\n                                            }), 64 /* STABLE_FRAGMENT */))\n                                        ]),\n                                        _createElementVNode(\"details\", _hoisted_28, [\n                                            _cache[43] || (_cache[43] = _createElementVNode(\"summary\", null, \"\", -1 /* CACHED */)),\n                                            _createElementVNode(\"ul\", _hoisted_29, [\n                                                (_openBlock(), _createElementBlock(_Fragment, null, _renderList(human_keys, (key) => {\n                                                    return _createElementVNode(\"li\", {\n                                                        key: `help-${key}`\n                                                    }, [\n                                                        _createElementVNode(\"strong\", null, _toDisplayString(key), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, _toDisplayString(human_attr_desc[key].), 1 /* TEXT */)\n                                                    ]);\n                                                }), 64 /* STABLE_FRAGMENT */))\n                                            ])\n                                        ]),\n                                        (_unref(create_error))\n                                            ? (_openBlock(), _createElementBlock(\"p\", _hoisted_30, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                            : _createCommentVNode(\"v-if\", true),\n                                        _createElementVNode(\"div\", _hoisted_31, [\n                                            _createElementVNode(\"button\", {\n                                                type: \"button\",\n                                                class: \"secondary-btn\",\n                                                onClick: _cache[8] || (_cache[8] = ($event) => (create_stage.value = 'profile'))\n                                            }, \"\"),\n                                            _createElementVNode(\"button\", {\n                                                type: \"button\",\n                                                class: \"start-btn\",\n                                                onClick: go_next_after_human\n                                            }, \"\")\n                                        ])\n                                    ]))\n                                    : (_unref(create_stage) === 'abilities')\n                                        ? (_openBlock(), _createElementBlock(\"section\", _hoisted_32, [\n                                            _cache[46] || (_cache[46] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                            _createElementVNode(\"p\", _hoisted_33, _toDisplayString(_unref(current_ability_hint)), 1 /* TEXT */),\n                                            _createElementVNode(\"p\", _hoisted_34, _toDisplayString(_unref(current_ability_title)), 1 /* TEXT */),\n                                            _createElementVNode(\"p\", _hoisted_35, \"\" + _toDisplayString(_unref(selected_abilities).length) + \"/\" + _toDisplayString(ability_pick_limit), 1 /* TEXT */),\n                                            _createElementVNode(\"ul\", _hoisted_36, [\n                                                (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(current_base_abilities), (ability) => {\n                                                    return (_openBlock(), _createElementBlock(\"li\", {\n                                                        key: ability.name\n                                                    }, [\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: _normalizeClass([\"ability-btn\", { active: _unref(selected_abilities).includes(ability.name) }]),\n                                                            onClick: ($event) => (toggle_ability(ability.name))\n                                                        }, [\n                                                            _createElementVNode(\"span\", null, _toDisplayString(ability.name), 1 /* TEXT */),\n                                                            _createElementVNode(\"small\", null, _toDisplayString(ability.desc), 1 /* TEXT */),\n                                                            _createElementVNode(\"small\", _hoisted_38, _toDisplayString(ability.source), 1 /* TEXT */)\n                                                        ], 10 /* CLASS, PROPS */, _hoisted_37)\n                                                    ]));\n                                                }), 128 /* KEYED_FRAGMENT */))\n                                            ]),\n                                            (_unref(create_error))\n                                                ? (_openBlock(), _createElementBlock(\"p\", _hoisted_39, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                                : _createCommentVNode(\"v-if\", true),\n                                            _createElementVNode(\"div\", _hoisted_40, [\n                                                _createElementVNode(\"button\", {\n                                                    type: \"button\",\n                                                    class: \"secondary-btn\",\n                                                    onClick: _cache[9] || (_cache[9] = ($event) => (create_stage.value = 'human'))\n                                                }, \"\"),\n                                                _createElementVNode(\"button\", {\n                                                    type: \"button\",\n                                                    class: \"start-btn\",\n                                                    onClick: go_next_after_abilities\n                                                }, \"\")\n                                            ])\n                                        ]))\n                                        : (_unref(create_stage) === 'profession')\n                                            ? (_openBlock(), _createElementBlock(\"section\", _hoisted_41, [\n                                                _cache[53] || (_cache[53] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                                _createElementVNode(\"p\", _hoisted_42, _toDisplayString(_unref(create_form).), 1 /* TEXT */),\n                                                (_unref(create_form). === '')\n                                                    ? (_openBlock(), _createElementBlock(_Fragment, { key: 0 }, [\n                                                        _createElementVNode(\"p\", _hoisted_43, \"\" + _toDisplayString(_unref(skill_points_left)) + \"/\" + _toDisplayString(skill_points_total) + \"4+2\", 1 /* TEXT */),\n                                                        _createElementVNode(\"ul\", _hoisted_44, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(current_warmaid_skills), (node) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", {\n                                                                    key: node.id\n                                                                }, [\n                                                                    _createElementVNode(\"button\", {\n                                                                        type: \"button\",\n                                                                        class: _normalizeClass([\"ability-btn\", { active: _unref(selected_warmaid_skills).includes(node.id) }]),\n                                                                        onClick: ($event) => (toggle_warmaid_skill(node.id))\n                                                                    }, [\n                                                                        _createElementVNode(\"span\", null, _toDisplayString(node.id) + \" \" + _toDisplayString(node.name) + \"\" + _toDisplayString(node.cost) + \"\", 1 /* TEXT */),\n                                                                        _createElementVNode(\"small\", null, _toDisplayString(node.desc), 1 /* TEXT */),\n                                                                        (node.prerequisites.length > 0)\n                                                                            ? (_openBlock(), _createElementBlock(\"small\", _hoisted_46, \" \" + _toDisplayString(node.prerequisites.join('')), 1 /* TEXT */))\n                                                                            : _createCommentVNode(\"v-if\", true)\n                                                                    ], 10 /* CLASS, PROPS */, _hoisted_45)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]),\n                                                        (_unref(cheat_mode))\n                                                            ? (_openBlock(), _createElementBlock(\"label\", _hoisted_47, [\n                                                                _cache[47] || (_cache[47] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                                _withDirectives(_createElementVNode(\"textarea\", {\n                                                                    \"onUpdate:modelValue\": _cache[10] || (_cache[10] = ($event) => (_isRef(warmaid_custom_skills) ? (warmaid_custom_skills).value = $event : null)),\n                                                                    rows: \"4\",\n                                                                    placeholder: \", \"\n                                                                }, null, 512 /* NEED_PATCH */), [\n                                                                    [_vModelText, _unref(warmaid_custom_skills)]\n                                                                ])\n                                                            ]))\n                                                            : _createCommentVNode(\"v-if\", true)\n                                                    ], 64 /* STABLE_FRAGMENT */))\n                                                    : (_unref(create_form). === '')\n                                                        ? (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [\n                                                            _createElementVNode(\"label\", _hoisted_48, [\n                                                                _cache[48] || (_cache[48] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                                _withDirectives(_createElementVNode(\"select\", {\n                                                                    \"onUpdate:modelValue\": _cache[11] || (_cache[11] = ($event) => ((_unref(authority_build).) = $event))\n                                                                }, [\n                                                                    (_openBlock(), _createElementBlock(_Fragment, null, _renderList(authority_paths, (path) => {\n                                                                        return _createElementVNode(\"option\", {\n                                                                            key: path,\n                                                                            value: path\n                                                                        }, _toDisplayString(path), 9 /* TEXT, PROPS */, _hoisted_49);\n                                                                    }), 64 /* STABLE_FRAGMENT */))\n                                                                ], 512 /* NEED_PATCH */), [\n                                                                    [_vModelSelect, _unref(authority_build).]\n                                                                ])\n                                                            ]),\n                                                            _createElementVNode(\"label\", _hoisted_50, [\n                                                                _cache[49] || (_cache[49] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                                _withDirectives(_createElementVNode(\"input\", {\n                                                                    \"onUpdate:modelValue\": _cache[12] || (_cache[12] = ($event) => ((_unref(authority_build).) = $event)),\n                                                                    type: \"text\",\n                                                                    placeholder: \"\"\n                                                                }, null, 512 /* NEED_PATCH */), [\n                                                                    [\n                                                                        _vModelText,\n                                                                        _unref(authority_build).,\n                                                                        void 0,\n                                                                        { trim: true }\n                                                                    ]\n                                                                ])\n                                                            ]),\n                                                            _createElementVNode(\"label\", _hoisted_51, [\n                                                                _cache[50] || (_cache[50] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                                _withDirectives(_createElementVNode(\"textarea\", {\n                                                                    \"onUpdate:modelValue\": _cache[13] || (_cache[13] = ($event) => ((_unref(authority_build).) = $event)),\n                                                                    rows: \"8\",\n                                                                    placeholder: \"(0)\\\\n\"\n                                                                }, null, 512 /* NEED_PATCH */), [\n                                                                    [\n                                                                        _vModelText,\n                                                                        _unref(authority_build).,\n                                                                        void 0,\n                                                                        { trim: true }\n                                                                    ]\n                                                                ])\n                                                            ]),\n                                                            _cache[51] || (_cache[51] = _createElementVNode(\"pre\", { class: \"example-box\" }, \"\\n\\n1\\n\\n(0)\\n\\n200\\n2d1520\\n345100\", -1 /* CACHED */)),\n                                                            _cache[52] || (_cache[52] = _createElementVNode(\"p\", { class: \"tip\" }, \"\", -1 /* CACHED */))\n                                                        ], 64 /* STABLE_FRAGMENT */))\n                                                        : (_openBlock(), _createElementBlock(\"p\", _hoisted_52, \"\")),\n                                                (_unref(create_error))\n                                                    ? (_openBlock(), _createElementBlock(\"p\", _hoisted_53, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                                    : _createCommentVNode(\"v-if\", true),\n                                                _createElementVNode(\"div\", _hoisted_54, [\n                                                    _createElementVNode(\"button\", {\n                                                        type: \"button\",\n                                                        class: \"secondary-btn\",\n                                                        onClick: _cache[14] || (_cache[14] = ($event) => (create_stage.value = 'abilities'))\n                                                    }, \"\"),\n                                                    _createElementVNode(\"button\", {\n                                                        type: \"button\",\n                                                        class: \"start-btn\",\n                                                        onClick: go_next_after_profession\n                                                    }, \"\")\n                                                ])\n                                            ]))\n                                            : (_unref(create_stage) === 'background')\n                                                ? (_openBlock(), _createElementBlock(\"section\", _hoisted_55, [\n                                                    _cache[57] || (_cache[57] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                                    _cache[58] || (_cache[58] = _createElementVNode(\"p\", { class: \"tip\" }, \"1000//\", -1 /* CACHED */)),\n                                                    _createElementVNode(\"div\", _hoisted_56, [\n                                                        _cache[54] || (_cache[54] = _createElementVNode(\"p\", { class: \"tip strong\" }, \"\", -1 /* CACHED */)),\n                                                        _createElementVNode(\"div\", _hoisted_57, [\n                                                            _createElementVNode(\"button\", {\n                                                                type: \"button\",\n                                                                class: \"secondary-btn\",\n                                                                onClick: _cache[15] || (_cache[15] = ($event) => (apply_background_starter(false)))\n                                                            }, \"\"),\n                                                            _createElementVNode(\"button\", {\n                                                                type: \"button\",\n                                                                class: \"secondary-btn\",\n                                                                onClick: _cache[16] || (_cache[16] = ($event) => (apply_background_starter(true)))\n                                                            }, \"\")\n                                                        ]),\n                                                        _createElementVNode(\"pre\", _hoisted_58, _toDisplayString(_unref(profession_background_starter)), 1 /* TEXT */)\n                                                    ]),\n                                                    _createElementVNode(\"label\", _hoisted_59, [\n                                                        _cache[55] || (_cache[55] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                        _withDirectives(_createElementVNode(\"textarea\", {\n                                                            \"onUpdate:modelValue\": _cache[17] || (_cache[17] = ($event) => (_isRef(background_input) ? (background_input).value = $event : null)),\n                                                            rows: \"12\",\n                                                            maxlength: \"1200\",\n                                                            placeholder: \"1000\"\n                                                        }, null, 512 /* NEED_PATCH */), [\n                                                            [\n                                                                _vModelText,\n                                                                _unref(background_input),\n                                                                void 0,\n                                                                { trim: true }\n                                                            ]\n                                                        ])\n                                                    ]),\n                                                    _createElementVNode(\"p\", _hoisted_60, \"\" + _toDisplayString(_unref(background_input).length) + \"/1200\", 1 /* TEXT */),\n                                                    (_unref(cheat_mode))\n                                                        ? (_openBlock(), _createElementBlock(\"label\", _hoisted_61, [\n                                                            _cache[56] || (_cache[56] = _createElementVNode(\"span\", null, \"\", -1 /* CACHED */)),\n                                                            _withDirectives(_createElementVNode(\"textarea\", {\n                                                                \"onUpdate:modelValue\": _cache[18] || (_cache[18] = ($event) => (_isRef(background_summary_override) ? (background_summary_override).value = $event : null)),\n                                                                rows: \"5\",\n                                                                placeholder: \"\"\n                                                            }, null, 512 /* NEED_PATCH */), [\n                                                                [\n                                                                    _vModelText,\n                                                                    _unref(background_summary_override),\n                                                                    void 0,\n                                                                    { trim: true }\n                                                                ]\n                                                            ])\n                                                        ]))\n                                                        : _createCommentVNode(\"v-if\", true),\n                                                    (_unref(create_error))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_62, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                                        : _createCommentVNode(\"v-if\", true),\n                                                    _createElementVNode(\"div\", _hoisted_63, [\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"secondary-btn\",\n                                                            onClick: _cache[19] || (_cache[19] = ($event) => (create_stage.value = 'profession'))\n                                                        }, \"\"),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"start-btn\",\n                                                            onClick: go_next_after_background\n                                                        }, \"\")\n                                                    ])\n                                                ]))\n                                                : (_openBlock(), _createElementBlock(\"section\", _hoisted_64, [\n                                                    _cache[59] || (_cache[59] = _createElementVNode(\"h2\", null, \" - \", -1 /* CACHED */)),\n                                                    _createElementVNode(\"p\", _hoisted_65, \"V0.5\" + _toDisplayString(_unref(create_form).), 1 /* TEXT */),\n                                                    _createElementVNode(\"ul\", _hoisted_66, [\n                                                        (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(current_dice_rules), (item) => {\n                                                            return (_openBlock(), _createElementBlock(\"li\", {\n                                                                key: item.key\n                                                            }, [\n                                                                _createElementVNode(\"span\", null, _toDisplayString(item.key), 1 /* TEXT */),\n                                                                _createElementVNode(\"strong\", null, _toDisplayString(item.rule), 1 /* TEXT */)\n                                                            ]));\n                                                        }), 128 /* KEYED_FRAGMENT */))\n                                                    ]),\n                                                    _createElementVNode(\"button\", {\n                                                        type: \"button\",\n                                                        class: \"start-btn\",\n                                                        onClick: roll_warmaid_stats\n                                                    }, \"\"),\n                                                    (_unref(warmaid_rolled))\n                                                        ? (_openBlock(), _createElementBlock(\"ul\", _hoisted_67, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(warmaid_result_list), (item) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", {\n                                                                    key: item.key\n                                                                }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(item.key), 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, _toDisplayString(item.value), 1 /* TEXT */)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                        : _createCommentVNode(\"v-if\", true),\n                                                    (_unref(create_error))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_68, _toDisplayString(_unref(create_error)), 1 /* TEXT */))\n                                                        : _createCommentVNode(\"v-if\", true),\n                                                    _createElementVNode(\"div\", _hoisted_69, [\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"secondary-btn\",\n                                                            onClick: _cache[20] || (_cache[20] = ($event) => (create_stage.value = 'background'))\n                                                        }, \"\"),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"start-btn\",\n                                                            onClick: finish_create\n                                                        }, \"\")\n                                                    ])\n                                                ]))\n                    ]))\n                    : (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [\n                        _createElementVNode(\"section\", {\n                            class: _normalizeClass([\"mvu-textbox\", { 'mvu-focus-mode': _unref(is_initial_mvu_focus_mode) }])\n                        }, [\n                            _createElementVNode(\"div\", _hoisted_70, [\n                                _cache[60] || (_cache[60] = _createElementVNode(\"h2\", null, \"MVU\", -1 /* CACHED */)),\n                                _createElementVNode(\"div\", _hoisted_71, [\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"status-toggle-btn\", { active: !_unref(status_bar_collapsed) }]),\n                                        onClick: toggle_status_bar\n                                    }, _toDisplayString(_unref(status_bar_collapsed) ? '' : ''), 3 /* TEXT, CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"plot-btn\", { active: _unref(plot_mode) }]),\n                                        onClick: toggle_plot_mode\n                                    }, _toDisplayString(_unref(plot_mode) ? '' : ''), 3 /* TEXT, CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass([\"mobile-btn\", { active: _unref(mobile_mode) }]),\n                                        onClick: toggle_mobile_mode\n                                    }, _toDisplayString(_unref(mobile_mode) ? '' : ''), 3 /* TEXT, CLASS */)\n                                ])\n                            ]),\n                            _createElementVNode(\"div\", _hoisted_72, [\n                                _cache[61] || (_cache[61] = _createElementVNode(\"span\", { class: \"mvu-font-label\" }, \"\", -1 /* CACHED */)),\n                                (_openBlock(), _createElementBlock(_Fragment, null, _renderList(mvu_font_size_options, (size) => {\n                                    return _createElementVNode(\"button\", {\n                                        key: size.key,\n                                        type: \"button\",\n                                        class: _normalizeClass([\"font-size-btn\", { active: _unref(mvu_font_size) === size.key }]),\n                                        onClick: ($event) => (mvu_font_size.value = size.key)\n                                    }, _toDisplayString(size.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_73);\n                                }), 64 /* STABLE_FRAGMENT */))\n                            ]),\n                            (_unref(display_floor_text))\n                                ? (_openBlock(), _createElementBlock(\"pre\", {\n                                    key: 0,\n                                    class: _normalizeClass([\"mvu-body\", `mvu-font-${_unref(mvu_font_size)}`])\n                                }, _toDisplayString(_unref(display_floor_text)), 3 /* TEXT, CLASS */))\n                                : (_openBlock(), _createElementBlock(\"p\", _hoisted_74, \"\")),\n                            _createElementVNode(\"div\", {\n                                class: _normalizeClass([\"next-actions\", { compact: _unref(is_initial_mvu_focus_mode) }])\n                            }, [\n                                _createElementVNode(\"div\", _hoisted_75, [\n                                    _createElementVNode(\"h3\", null, _toDisplayString(_unref(next_action_panel_mode) === 'options' ? '' : ''), 1 /* TEXT */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: \"next-actions-toggle-btn\",\n                                        onClick: toggle_next_action_panel_mode\n                                    }, _toDisplayString(_unref(next_action_panel_mode) === 'options' ? '' : ''), 1 /* TEXT */)\n                                ]),\n                                (_unref(next_action_panel_mode) === 'options')\n                                    ? (_openBlock(), _createElementBlock(\"div\", _hoisted_76, [\n                                        (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(next_action_options), (action) => {\n                                            return (_openBlock(), _createElementBlock(\"button\", {\n                                                key: action,\n                                                type: \"button\",\n                                                class: \"next-action-btn\",\n                                                onClick: ($event) => (send_next_action(action))\n                                            }, _toDisplayString(action), 9 /* TEXT, PROPS */, _hoisted_77));\n                                        }), 128 /* KEYED_FRAGMENT */))\n                                    ]))\n                                    : (_openBlock(), _createElementBlock(\"div\", _hoisted_78, [\n                                        _withDirectives(_createElementVNode(\"textarea\", {\n                                            \"onUpdate:modelValue\": _cache[21] || (_cache[21] = ($event) => (_isRef(manual_action_input) ? (manual_action_input).value = $event : null)),\n                                            class: \"next-actions-textarea\",\n                                            rows: \"3\",\n                                            placeholder: \"AIShift+\",\n                                            onKeydown: _withKeys(_withModifiers(send_manual_action, [\"exact\", \"prevent\"]), [\"enter\"])\n                                        }, null, 40 /* PROPS, NEED_HYDRATION */, _hoisted_79), [\n                                            [\n                                                _vModelText,\n                                                _unref(manual_action_input),\n                                                void 0,\n                                                { trim: true }\n                                            ]\n                                        ]),\n                                        _createElementVNode(\"div\", _hoisted_80, [\n                                            _createElementVNode(\"button\", {\n                                                type: \"button\",\n                                                class: \"secondary-btn\",\n                                                onClick: clear_manual_action\n                                            }, \"\"),\n                                            _createElementVNode(\"button\", {\n                                                type: \"button\",\n                                                class: \"start-btn\",\n                                                disabled: !_unref(manual_action_input).trim(),\n                                                onClick: send_manual_action\n                                            }, \"\", 8 /* PROPS */, _hoisted_81)\n                                        ])\n                                    ]))\n                            ], 2 /* CLASS */)\n                        ], 2 /* CLASS */),\n                        (_unref(data)... && _unref(data)... <= 0)\n                            ? (_openBlock(), _createElementBlock(\"section\", _hoisted_82, [\n                                _cache[62] || (_cache[62] = _createElementVNode(\"h2\", null, \"\", -1 /* CACHED */)),\n                                _createElementVNode(\"p\", null, _toDisplayString(_unref(data)... || ''), 1 /* TEXT */)\n                            ]))\n                            : _createCommentVNode(\"v-if\", true),\n                        (_unref(status_bar_collapsed))\n                            ? (_openBlock(), _createElementBlock(\"section\", _hoisted_83, [...(_cache[63] || (_cache[63] = [\n                                    _createElementVNode(\"p\", null, \"MVU\", -1 /* CACHED */)\n                                ]))]))\n                            : _createCommentVNode(\"v-if\", true),\n                        (!_unref(status_bar_collapsed))\n                            ? (_openBlock(), _createElementBlock(_Fragment, { key: 2 }, [\n                                _createElementVNode(\"header\", _hoisted_84, [\n                                    _createElementVNode(\"div\", null, [\n                                        _cache[64] || (_cache[64] = _createElementVNode(\"h1\", null, \"\", -1 /* CACHED */)),\n                                        _createElementVNode(\"p\", null, _toDisplayString(_unref(data)...) + \" | \" + _toDisplayString(_unref(profession)) + \" | \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                        _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(display_gender)), 1 /* TEXT */)\n                                    ]),\n                                    _createElementVNode(\"div\", _hoisted_85, [\n                                        _createElementVNode(\"span\", _hoisted_86, \": \" + _toDisplayString(_unref(data)..), 1 /* TEXT */),\n                                        _createElementVNode(\"button\", {\n                                            type: \"button\",\n                                            class: \"fullscreen-btn\",\n                                            onClick: _cache[22] || (_cache[22] = ($event) => (is_fullscreen.value = !_unref(is_fullscreen)))\n                                        }, _toDisplayString(_unref(is_fullscreen) ? '' : ''), 1 /* TEXT */)\n                                    ])\n                                ]),\n                                _createElementVNode(\"section\", _hoisted_87, [\n                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)..), 1 /* TEXT */),\n                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)..), 1 /* TEXT */),\n                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)..), 1 /* TEXT */)\n                                ]),\n                                _createElementVNode(\"nav\", _hoisted_88, [\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass({ active: _unref(active_tab) === 'main' }),\n                                        onClick: _cache[23] || (_cache[23] = ($event) => (active_tab.value = 'main'))\n                                    }, \"\", 2 /* CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass({ active: _unref(active_tab) === 'battle' }),\n                                        onClick: _cache[24] || (_cache[24] = ($event) => (active_tab.value = 'battle'))\n                                    }, \"\", 2 /* CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass({ active: _unref(active_tab) === 'recent' }),\n                                        onClick: _cache[25] || (_cache[25] = ($event) => (active_tab.value = 'recent'))\n                                    }, \"\", 2 /* CLASS */),\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: _normalizeClass({ active: _unref(active_tab) === 'warehouse' }),\n                                        onClick: _cache[26] || (_cache[26] = ($event) => (active_tab.value = 'warehouse'))\n                                    }, \"\", 2 /* CLASS */)\n                                ]),\n                                (_unref(active_tab) === 'main')\n                                    ? (_openBlock(), _createElementBlock(\"section\", _hoisted_89, [\n                                        _createElementVNode(\"div\", _hoisted_90, [\n                                            _createElementVNode(\"div\", _hoisted_91, [\n                                                _cache[65] || (_cache[65] = _createElementVNode(\"label\", null, \"\", -1 /* CACHED */)),\n                                                _createElementVNode(\"progress\", {\n                                                    value: _unref(data)...,\n                                                    max: _unref(data)...\n                                                }, null, 8 /* PROPS */, _hoisted_92),\n                                                _createElementVNode(\"strong\", _hoisted_93, _toDisplayString(_unref(data)...) + \"/\" + _toDisplayString(_unref(data)...), 1 /* TEXT */)\n                                            ]),\n                                            _createElementVNode(\"div\", _hoisted_94, [\n                                                _cache[66] || (_cache[66] = _createElementVNode(\"label\", null, \"\", -1 /* CACHED */)),\n                                                _createElementVNode(\"progress\", {\n                                                    value: _unref(data)...,\n                                                    max: _unref(data)...\n                                                }, null, 8 /* PROPS */, _hoisted_95),\n                                                _createElementVNode(\"strong\", _hoisted_96, _toDisplayString(_unref(data)...) + \"/\" + _toDisplayString(_unref(data)...), 1 /* TEXT */)\n                                            ]),\n                                            _createElementVNode(\"div\", _hoisted_97, [\n                                                _cache[67] || (_cache[67] = _createElementVNode(\"label\", null, \"\", -1 /* CACHED */)),\n                                                _createElementVNode(\"progress\", {\n                                                    value: _unref(data)...,\n                                                    max: \"100\"\n                                                }, null, 8 /* PROPS */, _hoisted_98),\n                                                _createElementVNode(\"strong\", _hoisted_99, _toDisplayString(_unref(data)...) + \"/100\", 1 /* TEXT */)\n                                            ])\n                                        ]),\n                                        _createElementVNode(\"div\", _hoisted_100, [\n                                            _createElementVNode(\"article\", null, [\n                                                _cache[68] || (_cache[68] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                _createElementVNode(\"ul\", _hoisted_101, [\n                                                    (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(human_attributes), (item) => {\n                                                        return (_openBlock(), _createElementBlock(\"li\", {\n                                                            key: item.key\n                                                        }, [\n                                                            _createElementVNode(\"span\", null, _toDisplayString(item.key), 1 /* TEXT */),\n                                                            _createElementVNode(\"strong\", null, _toDisplayString(item.value) + \" \" + _toDisplayString(item.training) + \"/100\", 1 /* TEXT */)\n                                                        ]));\n                                                    }), 128 /* KEYED_FRAGMENT */))\n                                                ])\n                                            ]),\n                                            (_unref(is_warmaid))\n                                                ? (_openBlock(), _createElementBlock(\"article\", _hoisted_102, [\n                                                    _cache[69] || (_cache[69] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    _createElementVNode(\"ul\", _hoisted_103, [\n                                                        (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(warmaid_attributes), (item) => {\n                                                            return (_openBlock(), _createElementBlock(\"li\", {\n                                                                key: item.key\n                                                            }, [\n                                                                _createElementVNode(\"span\", null, _toDisplayString(item.key), 1 /* TEXT */),\n                                                                _createElementVNode(\"strong\", null, _toDisplayString(item.value), 1 /* TEXT */)\n                                                            ]));\n                                                        }), 128 /* KEYED_FRAGMENT */))\n                                                    ])\n                                                ]))\n                                                : _createCommentVNode(\"v-if\", true)\n                                        ]),\n                                        _createElementVNode(\"div\", _hoisted_104, [\n                                            _createElementVNode(\"article\", null, [\n                                                _createElementVNode(\"h3\", null, _toDisplayString(_unref(level_label)), 1 /* TEXT */),\n                                                _createElementVNode(\"p\", _hoisted_105, _toDisplayString(_unref(level_value)), 1 /* TEXT */),\n                                                (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(level_meta_lines), (line) => {\n                                                    return (_openBlock(), _createElementBlock(\"p\", { key: line }, _toDisplayString(line), 1 /* TEXT */));\n                                                }), 128 /* KEYED_FRAGMENT */))\n                                            ]),\n                                            (_unref(is_warmaid))\n                                                ? (_openBlock(), _createElementBlock(\"article\", _hoisted_106, [\n                                                    _cache[70] || (_cache[70] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)... ? '' : '') + \"\" + _toDisplayString(_unref(data)...) + \"\", 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \"/\" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"button\", {\n                                                        type: \"button\",\n                                                        class: \"toggle-btn\",\n                                                        onClick: toggle_transform\n                                                    }, _toDisplayString(_unref(data)... ? '' : ''), 1 /* TEXT */)\n                                                ]))\n                                                : _createCommentVNode(\"v-if\", true)\n                                        ]),\n                                        _createElementVNode(\"article\", null, [\n                                            _cache[71] || (_cache[71] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                            (!_unref(has_real_skill_check))\n                                                ? (_openBlock(), _createElementBlock(\"p\", _hoisted_107, \"\"))\n                                                : (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \" \" + _toDisplayString(_unref(data)...) + \"\", 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \" + \" + _toDisplayString(_unref(data)...) + \" - \" + _toDisplayString(_unref(data)...) + \" = \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, _toDisplayString(_unref(data)...), 1 /* TEXT */)\n                                                ], 64 /* STABLE_FRAGMENT */))\n                                        ])\n                                    ]))\n                                    : (_unref(active_tab) === 'battle')\n                                        ? (_openBlock(), _createElementBlock(\"section\", _hoisted_108, [\n                                            _createElementVNode(\"div\", _hoisted_109, [\n                                                _createElementVNode(\"article\", null, [\n                                                    _cache[72] || (_cache[72] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \" / \" + _toDisplayString(_unref(data)... ? '' : ''), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \"/: \" + _toDisplayString(_unref(data)...) + \"/\" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                    (_unref(is_warmaid))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_110, \": \" + _toDisplayString(_unref(data)...) + \" / \" + _toDisplayString(_unref(data)...), 1 /* TEXT */))\n                                                        : _createCommentVNode(\"v-if\", true)\n                                                ]),\n                                                _createElementVNode(\"article\", null, [\n                                                    _cache[73] || (_cache[73] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    (_unref(_).isEmpty(_unref(data)..))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_111, \"\"))\n                                                        : (_openBlock(), _createElementBlock(\"ul\", _hoisted_112, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(data).., (v, k) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", { key: k }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(k) + \"(\" + _toDisplayString(v.) + \")\", 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, \"x\" + _toDisplayString(v.), 1 /* TEXT */)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                ])\n                                            ]),\n                                            (_unref(data)... === '')\n                                                ? (_openBlock(), _createElementBlock(\"article\", _hoisted_113, [...(_cache[74] || (_cache[74] = [\n                                                        _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"toggle-btn\",\n                                                            disabled: \"\"\n                                                        }, \" []\", -1 /* CACHED */)\n                                                    ]))]))\n                                                : _createCommentVNode(\"v-if\", true),\n                                            _createElementVNode(\"article\", null, [\n                                                _cache[75] || (_cache[75] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                (!_unref(has_real_skill_check))\n                                                    ? (_openBlock(), _createElementBlock(\"p\", _hoisted_114, \"\"))\n                                                    : (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [\n                                                        _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \" \" + _toDisplayString(_unref(data)...) + \"\", 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...) + \" + \" + _toDisplayString(_unref(data)...) + \" - \" + _toDisplayString(_unref(data)...) + \" = \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, \": \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, _toDisplayString(_unref(data)...), 1 /* TEXT */)\n                                                    ], 64 /* STABLE_FRAGMENT */))\n                                            ]),\n                                            (_unref(data)..)\n                                                ? (_openBlock(), _createElementBlock(\"article\", _hoisted_115, [\n                                                    _cache[76] || (_cache[76] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    (_unref(_).isEmpty(_unref(data)..))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_116, \"\"))\n                                                        : (_openBlock(), _createElementBlock(\"ul\", _hoisted_117, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(data).., (v, k) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", { key: k }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(k) + \"(\" + _toDisplayString(v.) + \")\", 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, \"x\" + _toDisplayString(v.), 1 /* TEXT */)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                ]))\n                                                : _createCommentVNode(\"v-if\", true)\n                                        ]))\n                                        : (_unref(active_tab) === 'recent')\n                                            ? (_openBlock(), _createElementBlock(\"section\", _hoisted_118, [\n                                                _createElementVNode(\"article\", null, [\n                                                    _cache[77] || (_cache[77] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    (_unref(_).isEmpty(_unref(data)..))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_119, \"\"))\n                                                        : (_openBlock(), _createElementBlock(\"ul\", _hoisted_120, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(data).., (v, k) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", { key: k }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(k), 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, _toDisplayString(v), 1 /* TEXT */)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                ]),\n                                                _createElementVNode(\"article\", null, [\n                                                    _cache[78] || (_cache[78] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    (_unref(_).isEmpty(_unref(data).))\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_121, \"\"))\n                                                        : (_openBlock(), _createElementBlock(\"ul\", _hoisted_122, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(data)., (v, k) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", { key: k }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(k), 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, _toDisplayString(v), 1 /* TEXT */)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                ])\n                                            ]))\n                                            : (_openBlock(), _createElementBlock(\"section\", _hoisted_123, [\n                                                _createElementVNode(\"div\", _hoisted_124, [\n                                                    _createElementVNode(\"article\", null, [\n                                                        _cache[79] || (_cache[79] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                        _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                        _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)....length), 1 /* TEXT */)\n                                                    ]),\n                                                    _createElementVNode(\"article\", null, [\n                                                        _cache[80] || (_cache[80] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                        (!_unref(data)...)\n                                                            ? (_openBlock(), _createElementBlock(\"p\", _hoisted_125, \"\"))\n                                                            : (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [\n                                                                _createElementVNode(\"p\", null, _toDisplayString(_unref(data)...) + \" / \" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                                _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)...) + \"\" + _toDisplayString(_unref(data)...) + \"\", 1 /* TEXT */),\n                                                                _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)...) + \"/\" + _toDisplayString(_unref(data)...), 1 /* TEXT */),\n                                                                _createElementVNode(\"p\", null, \"\" + _toDisplayString(_unref(data)... || ''), 1 /* TEXT */)\n                                                            ], 64 /* STABLE_FRAGMENT */))\n                                                    ])\n                                                ]),\n                                                _createElementVNode(\"article\", null, [\n                                                    _cache[81] || (_cache[81] = _createElementVNode(\"h3\", null, \"\", -1 /* CACHED */)),\n                                                    (_unref(warehouse_items).length === 0)\n                                                        ? (_openBlock(), _createElementBlock(\"p\", _hoisted_126, \"\"))\n                                                        : (_openBlock(), _createElementBlock(\"ul\", _hoisted_127, [\n                                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(warehouse_items), (item) => {\n                                                                return (_openBlock(), _createElementBlock(\"li\", {\n                                                                    key: item.name\n                                                                }, [\n                                                                    _createElementVNode(\"span\", null, _toDisplayString(item.name) + \"\" + _toDisplayString(item.quality) + \"\", 1 /* TEXT */),\n                                                                    _createElementVNode(\"strong\", null, \"x\" + _toDisplayString(item.count) + \" / \" + _toDisplayString(item.category) + \" / \" + _toDisplayString(item.value) + \"\", 1 /* TEXT */),\n                                                                    (item.usable)\n                                                                        ? (_openBlock(), _createElementBlock(\"button\", {\n                                                                            key: 0,\n                                                                            type: \"button\",\n                                                                            class: \"toggle-btn\",\n                                                                            onClick: ($event) => (use_warehouse_item(item.name))\n                                                                        }, \"  \", 8 /* PROPS */, _hoisted_128))\n                                                                        : _createCommentVNode(\"v-if\", true)\n                                                                ]));\n                                                            }), 128 /* KEYED_FRAGMENT */))\n                                                        ]))\n                                                ])\n                                            ])),\n                                _createElementVNode(\"section\", _hoisted_129, [\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: \"module-toggle\",\n                                        onClick: _cache[27] || (_cache[27] = ($event) => (toggle_module('')))\n                                    }, \" \" + _toDisplayString(_unref(onstage_characters).length) + \"\" + _toDisplayString(_unref(is_onstage_folded) ? '' : ''), 1 /* TEXT */),\n                                    (!_unref(is_onstage_folded))\n                                        ? (_openBlock(), _createElementBlock(\"ul\", _hoisted_130, [\n                                            (_unref(onstage_characters).length === 0)\n                                                ? (_openBlock(), _createElementBlock(\"li\", _hoisted_131, \"\"))\n                                                : _createCommentVNode(\"v-if\", true),\n                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(onstage_characters), (char) => {\n                                                return (_openBlock(), _createElementBlock(\"li\", {\n                                                    key: char.\n                                                }, [\n                                                    _createElementVNode(\"div\", _hoisted_132, [\n                                                        _createElementVNode(\"strong\", null, _toDisplayString(char.), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(char. || ''), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(char.), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(char.), 1 /* TEXT */),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"npc-delete-btn\",\n                                                            onClick: ($event) => (delete_onstage_npc(char.))\n                                                        }, \"\", 8 /* PROPS */, _hoisted_133)\n                                                    ]),\n                                                    _createElementVNode(\"p\", _hoisted_134, _toDisplayString(format_attr_text(char.)), 1 /* TEXT */),\n                                                    _createElementVNode(\"details\", null, [\n                                                        _cache[82] || (_cache[82] = _createElementVNode(\"summary\", null, \"\", -1 /* CACHED */)),\n                                                        _createElementVNode(\"p\", _hoisted_135, _toDisplayString(char. || ''), 1 /* TEXT */)\n                                                    ])\n                                                ]));\n                                            }), 128 /* KEYED_FRAGMENT */))\n                                        ]))\n                                        : _createCommentVNode(\"v-if\", true)\n                                ]),\n                                _createElementVNode(\"section\", _hoisted_136, [\n                                    _createElementVNode(\"button\", {\n                                        type: \"button\",\n                                        class: \"module-toggle\",\n                                        onClick: _cache[28] || (_cache[28] = ($event) => (toggle_module('NPC')))\n                                    }, \" NPC\" + _toDisplayString(_unref(longterm_npc_list).length) + \"\" + _toDisplayString(_unref(is_longterm_folded) ? '' : ''), 1 /* TEXT */),\n                                    (!_unref(is_longterm_folded))\n                                        ? (_openBlock(), _createElementBlock(\"ul\", _hoisted_137, [\n                                            (_unref(longterm_npc_list).length === 0)\n                                                ? (_openBlock(), _createElementBlock(\"li\", _hoisted_138, \"NPC\"))\n                                                : _createCommentVNode(\"v-if\", true),\n                                            (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(longterm_npc_list), (npc) => {\n                                                return (_openBlock(), _createElementBlock(\"li\", {\n                                                    key: npc.\n                                                }, [\n                                                    _createElementVNode(\"div\", _hoisted_139, [\n                                                        _createElementVNode(\"strong\", null, _toDisplayString(npc.), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(npc. || ''), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(npc.), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(npc.), 1 /* TEXT */),\n                                                        _createElementVNode(\"span\", null, \" \" + _toDisplayString(npc.), 1 /* TEXT */),\n                                                        _createElementVNode(\"button\", {\n                                                            type: \"button\",\n                                                            class: \"npc-delete-btn\",\n                                                            onClick: ($event) => (delete_longterm_npc(npc.))\n                                                        }, \"\", 8 /* PROPS */, _hoisted_140)\n                                                    ]),\n                                                    _createElementVNode(\"p\", _hoisted_141, _toDisplayString(format_attr_text(npc.)), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", _hoisted_142, \"\" + _toDisplayString((npc. || []).join(' / ') || ''), 1 /* TEXT */),\n                                                    _createElementVNode(\"p\", _hoisted_143, \"\" + _toDisplayString(npc.) + \" | \" + _toDisplayString(npc.), 1 /* TEXT */),\n                                                    _createElementVNode(\"details\", null, [\n                                                        _cache[83] || (_cache[83] = _createElementVNode(\"summary\", null, \"\", -1 /* CACHED */)),\n                                                        _createElementVNode(\"p\", _hoisted_144, _toDisplayString(npc. || ''), 1 /* TEXT */)\n                                                    ])\n                                                ]));\n                                            }), 128 /* KEYED_FRAGMENT */))\n                                        ]))\n                                        : _createCommentVNode(\"v-if\", true)\n                                ])\n                            ], 64 /* STABLE_FRAGMENT */))\n                            : _createCommentVNode(\"v-if\", true)\n                    ], 64 /* STABLE_FRAGMENT */))\n            ], 2 /* CLASS */));\n        };\n    }\n});\n","/* unplugin-vue-components disabled */import script from \"./App.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./App.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./App.vue?vue&type=style&index=0&id=1c716830&scoped=true&lang=css\"\n\nimport exportComponent from \"../../../../node_modules/.pnpm/vue-loader@17.4.2_vue@3.5.29_typescript@6.0.0-dev.20250807__webpack@5.105.2/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-1c716830\"]])\n\nexport default __exports__","import { waitUntil } from 'async-wait-until';\nimport App from './App.vue';\nimport './global.css';\n$(() => {\n    errorCatched(async () => {\n        await waitGlobalInitialized('Mvu');\n        await waitUntil(() => _.has(getVariables({ type: 'message' }), 'stat_data'));\n        const w = window;\n        const parent_w = (window.parent ?? {});\n        const element_ctor = w.Element || parent_w.Element || w.HTMLElement || parent_w.HTMLElement;\n        if (typeof w.SVGElement !== 'function' && typeof element_ctor === 'function')\n            w.SVGElement = element_ctor;\n        if (typeof w.MathMLElement !== 'function' && typeof element_ctor === 'function')\n            w.MathMLElement = element_ctor;\n        if (typeof w.HTMLElement !== 'function' && typeof element_ctor === 'function')\n            w.HTMLElement = element_ctor;\n        if (typeof w.Node !== 'function' && typeof parent_w.Node === 'function')\n            w.Node = parent_w.Node;\n        if (typeof w.ShadowRoot !== 'function' && typeof parent_w.ShadowRoot === 'function')\n            w.ShadowRoot = parent_w.ShadowRoot;\n        const root = document.getElementById('app');\n        if (!root)\n            return;\n        createApp(App).use(createPinia()).mount(root);\n    })();\n});\n"],"names":["exports","sfc","props","target","__vccOpts","key","val","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","n","getter","__esModule","d","a","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Vue","_","tryOnScopeDispose","fn","getCurrentScope","onScopeDispose","isClient","window","document","WorkerGlobalScope","globalThis","toString","isObject","noop","toRef","args","length","r","readonly","customRef","set","ref","createFilterWrapper","filter","Promise","resolve","reject","apply","this","thisArg","then","catch","bypassFilter","invoke","toArray","value","Array","isArray","cacheStringFunction","cache","create","str","hyphenateRE","camelizeRE","replace","toLowerCase","c","toUpperCase","getLifeCycleTarget","getCurrentInstance","watchWithFilter","source","cb","options","eventFilter","watchOptions","watch","watchPausable","initialState","pause","resume","isActive","extendFilter","pausableFilter","stop","useIntervalFn","interval","immediate","immediateCallback","timer","shallowRef","clean","clearInterval","intervalValue","toValue","setInterval","isRef","shallowReadonly","watchIgnorable","filteredCb","ignoreUpdates","ignorePrevAsyncUpdates","flush","ignore","updater","disposables","ignoreCounter","syncCounter","push","syncCounterPrev","forEach","z","Schema","object","boolean","prefault","string","enum","coerce","number","transform","v","clamp","array","record","describe","useDataStore","schema","variable_option","type","message_id","getCurrentMessageId","entries","sortBy","entry","map","join","errorCatched","data","parse","getVariables","reportInput","additional_setup","stat_data","result","safeParse","error","isEqual","updateVariablesWith","variables","new_data","deep","defaultWindow","navigator","location","unrefElement","elRef","_a","plain","$el","useEventListener","cleanups","cleanup","firstParamTargets","computed","test","e","every","stopWatch","_b","unref","raw_targets","raw_events","raw_listeners","raw_options","optionsClone","flatMap","el","event","listener","addEventListener","removeEventListener","register","Symbol","_global","self","globalKey","handlers","getHandlers","getSSRHandler","fallback","guessSerializerType","rawInit","Set","Map","Date","Number","isNaN","StorageSerializers","read","write","String","JSON","stringify","parseFloat","any","from","date","toISOString","customStorageEventName","useStorage","defaults","storage","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","console","initOnMounted","keyComputed","_a2","localStorage","serializer","pauseWatch","resumeWatch","newValue","oldValue","getItem","dispatchWriteEvent","removeItem","serialized","setItem","update","firstMounted","onStorageCustomEvent","ev","detail","payload","storageArea","dispatchEvent","Storage","StorageEvent","CustomEvent","serializedData","rawValue","nextTick","passive","sync","onMounted","tryOnMounted","useLocalStorage","initialValue","POSITIVE_INFINITY","_hoisted_1","class","_hoisted_2","_hoisted_3","_hoisted_4","_hoisted_5","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_hoisted_10","_hoisted_11","_hoisted_12","_hoisted_13","_hoisted_14","_hoisted_15","_hoisted_16","_hoisted_17","_hoisted_18","_hoisted_19","_hoisted_20","_hoisted_21","_hoisted_22","_hoisted_23","_hoisted_24","_hoisted_25","_hoisted_26","_hoisted_27","_hoisted_28","_hoisted_29","_hoisted_30","_hoisted_31","_hoisted_32","_hoisted_33","_hoisted_34","_hoisted_35","_hoisted_36","_hoisted_37","_hoisted_38","_hoisted_39","_hoisted_40","_hoisted_41","_hoisted_42","_hoisted_43","_hoisted_44","_hoisted_45","_hoisted_46","_hoisted_47","_hoisted_48","_hoisted_49","_hoisted_50","_hoisted_51","_hoisted_52","_hoisted_53","_hoisted_54","_hoisted_55","_hoisted_56","_hoisted_57","_hoisted_58","_hoisted_59","_hoisted_60","_hoisted_61","_hoisted_62","_hoisted_63","_hoisted_64","_hoisted_65","_hoisted_66","_hoisted_67","_hoisted_68","_hoisted_69","_hoisted_70","_hoisted_71","_hoisted_72","_hoisted_73","_hoisted_74","_hoisted_75","_hoisted_76","_hoisted_77","_hoisted_78","_hoisted_79","_hoisted_80","_hoisted_81","_hoisted_82","_hoisted_83","_hoisted_84","_hoisted_85","_hoisted_86","_hoisted_87","_hoisted_88","_hoisted_89","_hoisted_90","_hoisted_91","_hoisted_92","_hoisted_93","_hoisted_94","_hoisted_95","_hoisted_96","_hoisted_97","_hoisted_98","_hoisted_99","_hoisted_100","_hoisted_101","_hoisted_102","_hoisted_103","_hoisted_104","_hoisted_105","_hoisted_106","_hoisted_107","_hoisted_108","_hoisted_109","_hoisted_110","_hoisted_111","_hoisted_112","_hoisted_113","_hoisted_114","_hoisted_115","_hoisted_116","_hoisted_117","_hoisted_118","_hoisted_119","_hoisted_120","_hoisted_121","_hoisted_122","_hoisted_123","_hoisted_124","_hoisted_125","_hoisted_126","_hoisted_127","_hoisted_128","_hoisted_129","_hoisted_130","_hoisted_131","_hoisted_132","_hoisted_133","_hoisted_134","_hoisted_135","_hoisted_136","_hoisted_137","_hoisted_138","_hoisted_139","_hoisted_140","_hoisted_141","_hoisted_142","_hoisted_143","_hoisted_144","opening_story","xeno_opening_story","__name","setup","__props","store","is_fullscreen","mobile_mode","status_bar_collapsed","mvu_font_size","active_tab","display_floor_text","direct","trim","raw","content_match","match","extractFloorTextFromRaw","default_next_action_options","next_action_options","next_action_panel_mode","manual_action_input","is_initial_mvu_focus_mode","onstage_characters","list","module_fold_state","is_onstage_folded","Boolean","is_longterm_folded","longterm_npc_list","values","warehouse_items","name","quality","count","category","usable","is_library_invitation_item","sort","b","includes","create_profile_valid","build","profession_ok","name_ok","is_default_name","gender","gender_ok","show_create","has_real_skill_check","desc","create_stage","create_error","cheat_mode","plot_mode","xeno_route_mode","xeno_route_role","draft_initialized","warmaid_types","human_keys","human_attr_desc","mvu_font_size_options","label","base_ability_map","human_caps","warmaid_dice_rules","age_limit_map","min","max","authority_paths","authority_forbidden_pattern","background_filter_pattern","training_keyword_pattern","warmaid_skill_tree","id","cost","prerequisites","profession_background_starters","create_form","reactive","selected_warmaid_skills","warmaid_custom_skills","background_input","background_summary_override","authority_build","human_attr","warmaid_attr","warmaid_rolled","selected_abilities","age_limit","human_points_left","current_base_abilities","current_ability_title","current_ability_hint","current_warmaid_skills","selected_warmaid_skill_cost","reduce","sum","skill_points_left","Math","current_dice_rules","rule","warmaid_result_list","profession","saved","display_gender","is_warmaid","human_attributes","base","train","add_str","add_con","training","warmaid_attributes","level_label","warmaid_rank_names","authority_rank_names","level_value","idx","level_meta_lines","current","next","need","shard","has_origin","lv","format_attr_text","attrs","k","toggle_module","module_name","toggle_plot_mode","sync_xeno_route_profession","start_xeno_route","start_normal_route","build_next_actions_from_reply","text","t","bad_action_pattern","action_noise_pattern","normalize_action","pool","pushUnique","s","action","direct_candidates","split","line","out","m1","m2","candidate","current_stage","first_npc","ensure_four_actions","slice","item","change_human","delta","go_human_step","limit","age","isFinite","go_next_after_human","go_next_after_abilities","toggle_warmaid_skill","skill_id","node","find","some","pre","hasWarmaidSkillPrerequisites","validateAuthorityBuild","merged","go_next_after_profession","authority_err","go_next_after_background","finish_create","rollD","sides","floor","random","rollExpr","expr","m","total","i","roll_warmaid_stats","bg_raw","bg_summary","training_source","training_state","max_hp","max_mp","ceil","fromEntries","now","toggle_transform","async","dispatch_action_to_tavern","createChatMessages","role","message","triggerSlash","warn","ts","parent","postMessage","top","docs","textarea_selectors","send_btn_selectors","doc","input_el","sel","querySelector","HTMLTextAreaElement","Event","bubbles","btn","HTMLElement","click","info","send_next_action","confirm","toggle_next_action_panel_mode","clear_manual_action","send_manual_action","toggle_mobile_mode","toggle_status_bar","valid_ability_names","has","assign","show","watchEffect","profession_background_starter","apply_background_starter","append","starter","_ctx","_cache","fullscreen","onClick","active","$event","placeholder","kind","disabled","ability","rows","path","maxlength","size","compact","onKeydown","isEmpty","item_name","stock","char","raw_name","npc","onstage","$","waitGlobalInitialized","w","parent_w","element_ctor","Element","SVGElement","MathMLElement","Node","ShadowRoot","root","getElementById","createApp","App","use","mount"],"sourceRoot":""}